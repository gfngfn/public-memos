
# 1章 暗号の基礎知識

## 1 情報セキュリティ

### 情報セキュリティの3要素

- **機密性** (confidentiality)：
  + **認可** されていない人が情報にアクセスできないこと．
  + 通信内容の暗号化，サーバに保存するデータの暗号化，アクセス制御のための **認証** により実現する．
- **完全性** (integrity)：
  + 情報が改竄されたり消えたりしないこと．
  + 改竄されていないかの検証には **メッセージ認証符号** や **署名** と呼ばれる技術が使われる．
- **可用性** (availability)：
  + （システムが破損してもすぐに復旧できるなどして）認可された人が必要な時に情報にアクセスできるようになっていること．
  + サーバの冗長性を高めるほかに，情報を安全に分散して保存する **秘密分散** という技術が使える．


### 情報セキュリティと暗号技術

情報セキュリティは **JIS Q 27000** で定義されている．


### 追加された要件

情報セキュリティの3要素に加えて，より重要な情報を扱う際には次の要件を考慮することがある：

- **真正性**：
  + ユーザやシステムが本当にその人やものであって偽物が紛れ込んでいないこと．
  + この確度を上げるために **二段階認証** が使われたりする．一般に認証の制度を上げようとするとユーザやサービス提供者の負担が上がる．
- **責任追跡性**：
  + システムが変な挙動をしたり攻撃されたりしたときに起きたことやその原因を追跡できること．
  + ログによって実現する．そのためにはログの完全性が前提となる．ログが完全でなく改竄されるリスクがあると誤った犯人を特定してしまうおそれがある．
- **否認防止**：
  + 取引や登録などの操作を後でなかったことにされないようにすること．
- **信頼性**：
  + システムが不具合なく正確に動作すること．


## 2 暗号

### 暗号とは

第三者が見てもわからない形に変換することを **暗号化する** (encrypt) といい，変換前のデータを **平文**，変換後のデータを **暗号文** と呼ぶ．暗号文を平文に戻すことを **復号する** (decrypt) という．

一般にこの変換には平文や暗号文のほかに **鍵** と呼ばれる付加情報を使う．暗号化に使う鍵を **暗号鍵**，復号に使う鍵を **復号鍵** と呼ぶ．

正規の復号手順を踏まずに（つまり暗号開発者の意図しなかった形で）平文の情報を取得することを **解読する**，或いは単に **攻撃する** という．平文の全部でなく一部の情報が判明することであっても解読とか攻撃と呼ぶことに注意．


## よい暗号

一般に手順が広く公開されて研究者らがその安全性を検証しているものがよい．手順が非公開のものは開発者の意図しない欠陥があっても気づかれにくいなどして望ましくない．


## 暗号の動向を知る

安全と思われていた技術が或る時そうでないとわかることもあるため，動向を注視する必要がある．

- 暗号技術評価委員会 (**CRYPTREC**, Cryptography research and evaluation committees)： 暗号の安全性を評価・監視する日本国内の機関．
- 米国国立標準技術研究所 (**NIST**, National Institute of Standards and Technology)： 情報技術研究所 (**ITL**, Information Technology Laboratory) という研究部門があり，セキュリティに関する標準化をしている．
- **IETF** (Internet Engineering Task Force)： RFCを策定し公開している．例えばTLSの仕様もこれの一部（→7章）．


## 3 認証

### パスワードによる認証

或る人が他人に対して確かにその対象本人であると確認する手続きを **認証** (authentication) と呼ぶ．一般に認証にはユーザに対して払い出されたIDおよびユーザが設定したパスワードが使用される．


### パスワード攻撃者の能力

パスワードを推測する攻撃者の能力は状況によって大きく異なる．例えばATMのパスワードは4桁しかなかったりするが，数回間違えるとロックされるようになっていること，監視カメラのある状況でしか使えないことによって攻撃のロスクが高く，概ね安全と合意されている．一方で暗号化されたファイルの解読はマシンパワーがいくらでも使えるので攻撃のリスクが低い．


### パスワードの攻撃方法

- **辞書攻撃**：
  + `password` とか `12345678` といったありそうなパスワード一覧を用意して全部試す方法．
  + ATMのように「何度か間違えたらロックする」機構を用意することで回避できる．
- **ブルートフォース攻撃**：
  + ユーザIDを固定し，パスワードを総当たりする攻撃．
- **リバースブルートフォース攻撃**：
  + パスワードを固定し，ユーザIDを総当たりする攻撃
- **パスワードスプレー攻撃**：
  + リバースブルートフォース攻撃の特殊な場合で，`(パスワード, ユーザID)` の順の入れ子で2重ループするもの．
  + 時間を空けたり複数の接続元から分散したりして攻撃が行なわれ，かつ或るユーザIDに対して連続的に攻撃するわけではないので検出しづらい．
  + **多要素認証** （後述）によって防御できる．

なお，複雑なパスワードを使っていても1箇所漏れると他のあらゆるサービスで同じパスワードを使って攻撃されるリスクがあるので使い回すべきではない．


### 認証の分類

- **知識認証**：
  + その人だけが知っていることが想定される知識による認証．
  + 通常のパスワードもこれにあたる．
- **生体認証**：
  + 指紋や静脈など．
- **所有物認証**：
  + その人しか持っていないものを利用したもの．
  + **ワンタイムパスワード生成器** などによる．これは銀行などが提供する機材で，送金などの重要な操作の時に，ワンタイムパスワード生成器が時刻に応じて生成して表示した列をパスワードに加えて入力するというもの．
- **クライアント証明書**：
  + ユーザごとに発行され，単一の計算機にインストールしてログイン時に認証に使われる機構．
  + サービス提供者が特にセキュリティを重視するときに使われる．


### 認可

ユーザのアクセス権限に応じてシステムへのアクセス権限を決めることを **認可** (authorization) と呼ぶ．


### OAuth

例として，写真をクラウドに保存できるサービス S と写真を編集して公開できるアプリケーション A があり，S に保存している写真の一部を A で編集して公開することが多いとする．毎回 S にログインしていては面倒なので，一旦ログインしたらよいという機能を実現したい．S が写真にアクセスするAPIを提供し，A がそのAPIを経由して取ってこられるようにしたい（A のインターフェイス上で「S からインポート」のようなボタンがあるようなイメージ）．しかし，ここで「ユーザが S のログインパスワードを A に教える」という方法をとるのは（A がそのパスワードをユーザの知らないところで悪用する可能性が排除できず）良い方法ではない．このような問題を解決し，A が S のAPIを利用できるように認可する仕組みである **OAuth** 2.0 (Open Authorization) が考案された．

上記の例を引き続き使うと，OAuthでは A がパスワードの代わりに **アクセストークン** というデータを用いて S にアクセスする．アクセストークンを発行する主体（ここでは S が提供している）を **認可サーバ**，アクセスを依頼する側（ここでは A）を単にクライアントと呼ぶ．アクセストークンでできることはパスワードに比べて制限されており，それゆえにパスワードに比べれば安全になっている．

アクセストークンの発行手順は典型的には以下の流れによる：

1. クライアントが認可サーバに対してブラウザ経由でクライアントIDとリダイレクト用のURIを添えた認可リクエストを送る．
2. 認可サーバはブラウザ経由でユーザ認証を行ない，ユーザに許可を求める許諾画面を出す．
   - Twitterの「○○にアカウントへのアクセスを許可しますか？」の画面など．
3. ユーザの許可が出れば，認可サーバ（が生成したブラウザで動くプログラム）はリダイレクトし，**認可コード** をクライアントに送る．
4. クライアントは認可コードとリダイレクトURIを認可サーバに送る．
5. 認可サーバがクライアントを認証し，認可コードとリダイレクトURIを検証してアクセストークンをクライアントに送る．

ここで認可コードは一時的に生成されたランダムな数値で，有効期間は典型的には10分など．かつてはステップ3で認可コードではなく直接アクセストークンを返してそれで終わりという **インプリシットグラント** (implicit grant) という方法もあったが，安全性に問題があるため今では非推奨．


## 4 古典暗号

1970後半から始まった系統だった学問としての暗号を **現代暗号** と呼び，対照的にそれより以前の時代のものを **古典暗号** と呼ぶ．

この節は単にシフト暗号と換字式暗号の紹介．


# 2章

## 5 アルゴリズム

流石に知っていることしかないので飛ばす．


## 6 安全性

これも時間計算量などほぼ知っていることなので以下だけメモ：

- 秘密鍵のビット長を **鍵長** と呼ぶ．
- 暗号を解読するのに必要な時間計算量などのコストを **セキュリティパラメータ** と呼ぶ．
- 或る暗号に於いて，n ビットのデータに対する総当たりしか攻撃方法が知られていない場合，その暗号は **n ビットセキュリティ** であるという．


## 7 暗号技術の危殆（キタイ）化

### コンピュータの性能向上と暗号の安全性

各暗号で128ビットセキュリティを達成するために必要な鍵長：

- 共通鍵暗号： 128ビット
- ハッシュ関数： 256ビット
- RSA暗号： 約3000
- 楕円曲線暗号： 256ビット

2020年には鍵長800ビットのRSA暗号が破られており，1024ビットも1年ほどスーパーコンピュータを回せば破れると推測されるため2048ビット以上が推奨されている．


### 運用監視暗号リストと推奨暗号リスト

国内ではCRYPTECが運用監視暗号リストと推奨暗号リストを後悔している．前者は互換性維持以外を目的としての使用を推奨しないもの．


### 危殆化の問題点

現在インターネットで使用されている暗号はおそらく2030年を超えても当面は安全だろうとされているが，半世紀後もそうかはわからない．

ゲノムのような，漏洩すると子孫にも永久に影響が残るような情報はとりわけ取り扱いが難しい．少なくとも現時点では残念ながら未来永劫安全になるように大きなデータを手元の小さい鍵で暗号化しておく方法は存在していない．


# 3章 共通鍵暗号

## 8 共通鍵暗号

### 共通鍵暗号とは

暗号化に使う鍵（＝秘密鍵）と復号に使う鍵が同じである暗号方式を **共通鍵暗号**（または **秘密鍵暗号** や **対称鍵暗号**）と呼ぶ．これを使う場合，暗号化する人と復号する人で事前に秘密鍵を共有し他者には漏らさないようにしなければならない．


### 共通鍵暗号に求められる安全性

厳密な定義は難しいので概略を示す：

- 強秘匿性：
  + 暗号文から平文を一部でも推測するのが困難なこと．
  + 例えば平文を少し変えただけで暗号文が全く異なるものとなるなど．
- 選択平文攻撃への耐性：
  + `(平文, 暗号文)` の組がいくつか盗聴によって漏れたとしてもそれを一般の暗号文の解読に利用するのは困難であること．
  + このような盗聴は通信されるデータのヘッダに平文の一部が漏れていたりすることなどによって起きることが想定される．
  + ほかにも **選択暗号文攻撃**（**CCA**，→p.117）を想定することもある．


### 共通鍵暗号の種類

共通鍵暗号は **ブロック暗号** と **ストリーム暗号** に大別される．ブロック暗号は平文を複数のブロックに分割してブロックごとに暗号化する．ストリーム暗号は乱数によってノイズを生成しそれと平文を混ぜて暗号化する．


## 9 ビットと排他的論理和

これも流石に知っているが，以下だけ重要：

```
(a xor b) xor b = a
```

証明は `xor` の結合律から従う：

```
(a xor b) xor b
  = a xor (b xor b)
  = a xor 0
  = a
```

`a` を暗号文，`b` を秘密鍵とみなすとよい．


## 10 乱数

### 真の乱数

“次にどんな値になるか予測できない数列” を **乱数列** といい，乱数列のそれぞれの値を **乱数** と呼ぶ．

真の乱数は，一度得られた乱数列の全部またはそれに等価なデータを記録しておかない限り復元することはできないという意味で **再現不可能性** をもつという．


### コンピュータで扱う乱数

通常のソフトウェアで再現不可能な乱数を生成するのは難しいため，乱数列を生成する専用のハードウェアが開発されている．ただし，乱数生成用ハードウェアはブラックボックスなのでベンダが制御している可能性も排除はできないし，不具合で乱数になっていない可能性もある．実際2019年7月にはAMDのCPUに乱数生成命令が固定値を返す場合がある不具合が発見されたし，2020年6月にはIntelのCPUに於いて乱数生成命令が生成した乱数を他のプロセスから盗み見る攻撃手法が発見された．Linuxの `/dev/random` はハードウェアだけでなく様々なデータも組み合わせて使っており，どれか1つに問題があっても最終的な出力には問題がないように実装されているらしい．


### 擬似乱数

**シード** (seed) と呼ばれる初期状態をもとに，あるアルゴリズムによって一見真の乱数に見えるような列を出力する方法があり，このようなアルゴリズムないし装置を **擬似乱数生成器** といい，これに生成された列を **擬似乱数列** と呼ぶ．擬似乱数列はシードが決まれば列は変わらないため，再現不可能性はもっていない．

擬似乱数はシードさえ漏洩しなければ乱数のように扱える．

Linuxの `/dev/urandom` は擬似乱数生成器．


### 擬似ランダム函数

**シード** と任意の整数を受け取って乱数を出力する函数を **擬似ランダム函数** (pseudorandom function, PRF) と呼ぶ．気持ちとしてはシードを部分適用すると乱数を返す函数が得られるという具合．

擬似乱数生成器があれば擬似ランダム函数が構成できることが知られている．

> 疑問： 自然に考えると単に擬似乱数の列をそのまま添字アクセスすることで確かに擬似ランダム函数にできるが，これはかなりパフォーマンスが悪いはずで，第2引数に対して線型時間かかる．もっとパフォーマンスが良い構成方法があるのかも？


## 11 ワンタイムパッド

実用には即さないが，平文 `m` に対して毎回その平文と同じビット長の秘密鍵 `s` を生成して暗号化に使う **ワンタイムパッド** (one-time pad, OTP) という方式は **情報論的安全性** を満たすことが知られている．

暗号化と復号化の方式としては単にbitwiseに排他的論理和を取るだけ：

```
Enc(s, m) := m ⊕ s
Dec(s, c) := c ⊕ s

Dec(s, Enc(s, m)) = (m ⊕ s) ⊕ s = m
```

“秘密鍵 `s` の生成に偏りがなければ暗号文には一切秘密鍵の情報が漏れない” という点で情報理論的に安全で，全探索よりも良い攻撃方法がない．


## 12 ストリーム暗号

ワンタイムパッドをもう少し実用に即したものにするために，“ワンタイムパッドの秘密鍵に使う乱数を擬似乱数に置き換えた変種” を考える．こうすれば，擬似乱数を生成するシードだけを秘密鍵として最初に共有すればよいので，秘密鍵のサイズが減る．こうした方式を **ストリーム暗号** と呼ぶ．76ページの図を参照．

ただし，ここでシードを “もともとの秘密鍵” よりも真に短くしたことにより，情報論的安全性は満たさなくなる．というのも，シードが `n` ビットなら擬似乱数列は高々 `2^n` 種類しかないため．

> 疑問： ここの書籍での説明は若干変な気がする？ 原理的には，擬似乱数列として出ないパターンがある（例えば，長さ `n` の10ビット値の列は `(2^10)^n` 通りあるが，シードが8ビットならそのうちの `2^8` 通りしか出ない）のであって，単一の擬似乱数として出ない値があるというわけではないはず．

しかし，それでもシードに対する全探索以上によい解読方法がなければ `n` ビットセキュリティを達成することができ，現在は `n = 128` 程度で安全であろうとされている．こうした安全性の考え方を **計算量的安全性** と呼ぶ．


### ナンス

シードが同一なら同一の擬似乱数列が生成されるので，1つのシードは1回しか使えない．これは不便なので，擬似乱数列の生成にシードとは別に **ナンス** (nonce) という値を入力できるようにし，ナンスを通信ごとに毎回変えることによってシードを繰り返し利用できるようにするという方式が採られたりする．“従来のシードをナンスと新しい固定できるシードから生成できるようにする” 方式とも言えそう．


### ChaCha20

**ChaCha20** は，D. J. Bernsteinによって2008年に開発された，256ビットの秘密鍵と96ビットのナンスを元に512ビットずつの擬似乱数列を生成するストリーム暗号．ChaCha20で用いられている擬似ランダム函数は **4分の1ラウンド函数** と呼ばれる函数を使っている．まず最初に固定の定数128ビット，秘密鍵256ビット，カウンタ32ビット，ナンス96ビットの合計512ビットを32ビット整数16個に分けて4×4の正方形に配置し，これに対して1/4ラウンド函数という “かき混ぜ処理” を8回1セットとして10セット適用し，最終的に得られた512ビットを出力乱数とするというもの．カウンタは単に 1, 2, 3, … とインクリメントするだけ．

1/4ラウンド函数の定義は80ページ参照．


## 13 ブロック暗号

平文を **ブロック** と呼ぶ一定の長さごとの単位に切り分け，そのブロックごとに暗号化する方式を **ブロック暗号** と呼ぶ．分割時に端数があれば，残りの部分をパディングで埋めてそれを最後の1ブロックとする．
