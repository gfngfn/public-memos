
# 1章 暗号の基礎知識

## 1 情報セキュリティ

### 情報セキュリティの3要素

- **機密性** (confidentiality)：
  + **認可** されていない人が情報にアクセスできないこと．
  + 通信内容の暗号化，サーバに保存するデータの暗号化，アクセス制御のための **認証** により実現する．
- **完全性** (integrity)：
  + 情報が改竄されたり消えたりしないこと．
  + 改竄されていないかの検証には **メッセージ認証符号** や **署名** と呼ばれる技術が使われる．
- **可用性** (availability)：
  + （システムが破損してもすぐに復旧できるなどして）認可された人が必要な時に情報にアクセスできるようになっていること．
  + サーバの冗長性を高めるほかに，情報を安全に分散して保存する **秘密分散** という技術が使える．


### 情報セキュリティと暗号技術

情報セキュリティは **JIS Q 27000** で定義されている．


### 追加された要件

情報セキュリティの3要素に加えて，より重要な情報を扱う際には次の要件を考慮することがある：

- **真正性**：
  + ユーザやシステムが本当にその人やものであって偽物が紛れ込んでいないこと．
  + この確度を上げるために **二段階認証** が使われたりする．一般に認証の制度を上げようとするとユーザやサービス提供者の負担が上がる．
- **責任追跡性**：
  + システムが変な挙動をしたり攻撃されたりしたときに起きたことやその原因を追跡できること．
  + ログによって実現する．そのためにはログの完全性が前提となる．ログが完全でなく改竄されるリスクがあると誤った犯人を特定してしまうおそれがある．
- **否認防止**：
  + 取引や登録などの操作を後でなかったことにされないようにすること．
- **信頼性**：
  + システムが不具合なく正確に動作すること．


## 2 暗号

### 暗号とは

第三者が見てもわからない形に変換することを **暗号化する** (encrypt) といい，変換前のデータを **平文**，変換後のデータを **暗号文** と呼ぶ．暗号文を平文に戻すことを **復号する** (decrypt) という．

一般にこの変換には平文や暗号文のほかに **鍵** と呼ばれる付加情報を使う．暗号化に使う鍵を **暗号鍵**，復号に使う鍵を **復号鍵** と呼ぶ．

正規の復号手順を踏まずに（つまり暗号開発者の意図しなかった形で）平文の情報を取得することを **解読する**，或いは単に **攻撃する** という．平文の全部でなく一部の情報が判明することであっても解読とか攻撃と呼ぶことに注意．


### よい暗号

一般に手順が広く公開されて研究者らがその安全性を検証しているものがよい．手順が非公開のものは開発者の意図しない欠陥があっても気づかれにくいなどして望ましくない．


### 暗号の動向を知る

安全と思われていた技術が或る時そうでないとわかることもあるため，動向を注視する必要がある．

- 暗号技術評価委員会 (**CRYPTREC**, Cryptography research and evaluation committees)： 暗号の安全性を評価・監視する日本国内の機関．
- 米国国立標準技術研究所 (**NIST**, National Institute of Standards and Technology)： 情報技術研究所 (**ITL**, Information Technology Laboratory) という研究部門があり，セキュリティに関する標準化をしている．
- **IETF** (Internet Engineering Task Force)： RFCを策定し公開している．例えばTLSの仕様もこれの一部（→7章）．


## 3 認証

### パスワードによる認証

或る人が他人に対して確かにその対象本人であると確認する手続きを **認証** (authentication) と呼ぶ．一般に認証にはユーザに対して払い出されたIDおよびユーザが設定したパスワードが使用される．


### パスワード攻撃者の能力

パスワードを推測する攻撃者の能力は状況によって大きく異なる．例えばATMのパスワードは4桁しかなかったりするが，数回間違えるとロックされるようになっていること，監視カメラのある状況でしか使えないことによって攻撃のロスクが高く，概ね安全と合意されている．一方で暗号化されたファイルの解読はマシンパワーがいくらでも使えるので攻撃のリスクが低い．


### パスワードの攻撃方法

- **辞書攻撃**：
  + `password` とか `12345678` といったありそうなパスワード一覧を用意して全部試す方法．
  + ATMのように「何度か間違えたらロックする」機構を用意することで回避できる．
- **ブルートフォース攻撃**：
  + ユーザIDを固定し，パスワードを総当たりする攻撃．
- **リバースブルートフォース攻撃**：
  + パスワードを固定し，ユーザIDを総当たりする攻撃
- **パスワードスプレー攻撃**：
  + リバースブルートフォース攻撃の特殊な場合で，`(パスワード, ユーザID)` の順の入れ子で2重ループするもの．
  + 時間を空けたり複数の接続元から分散したりして攻撃が行なわれ，かつ或るユーザIDに対して連続的に攻撃するわけではないので検出しづらい．
  + **多要素認証** （後述）によって防御できる．

なお，複雑なパスワードを使っていても1箇所漏れると他のあらゆるサービスで同じパスワードを使って攻撃されるリスクがあるので使い回すべきではない．


### 認証の分類

- **知識認証**：
  + その人だけが知っていることが想定される知識による認証．
  + 通常のパスワードもこれにあたる．
- **生体認証**：
  + 指紋や静脈など．
- **所有物認証**：
  + その人しか持っていないものを利用したもの．
  + **ワンタイムパスワード生成器** などによる．これは銀行などが提供する機材で，送金などの重要な操作の時に，ワンタイムパスワード生成器が時刻に応じて生成して表示した列をパスワードに加えて入力するというもの．
- **クライアント証明書**：
  + ユーザごとに発行され，単一の計算機にインストールしてログイン時に認証に使われる機構．
  + サービス提供者が特にセキュリティを重視するときに使われる．


### 認可

ユーザのアクセス権限に応じてシステムへのアクセス権限を決めることを **認可** (authorization) と呼ぶ．


### OAuth

例として，写真をクラウドに保存できるサービス S と写真を編集して公開できるアプリケーション A があり，S に保存している写真の一部を A で編集して公開することが多いとする．毎回 S にログインしていては面倒なので，一旦ログインしたらよいという機能を実現したい．S が写真にアクセスするAPIを提供し，A がそのAPIを経由して取ってこられるようにしたい（A のインターフェイス上で「S からインポート」のようなボタンがあるようなイメージ）．しかし，ここで「ユーザが S のログインパスワードを A に教える」という方法をとるのは（A がそのパスワードをユーザの知らないところで悪用する可能性が排除できず）良い方法ではない．このような問題を解決し，A が S のAPIを利用できるように認可する仕組みである **OAuth** 2.0 (Open Authorization) が考案された．

上記の例を引き続き使うと，OAuthでは A がパスワードの代わりに **アクセストークン** というデータを用いて S にアクセスする．アクセストークンを発行する主体（ここでは S が提供している）を **認可サーバ**，アクセスを依頼する側（ここでは A）を単にクライアントと呼ぶ．アクセストークンでできることはパスワードに比べて制限されており，それゆえにパスワードに比べれば安全になっている．

アクセストークンの発行手順は典型的には以下の流れによる：

1. クライアントが認可サーバに対してブラウザ経由でクライアントIDとリダイレクト用のURIを添えた認可リクエストを送る．
2. 認可サーバはブラウザ経由でユーザ認証を行ない，ユーザに許可を求める許諾画面を出す．
   - Twitterの「○○にアカウントへのアクセスを許可しますか？」の画面など．
3. ユーザの許可が出れば，認可サーバ（が生成したブラウザで動くプログラム）はリダイレクトし，**認可コード** をクライアントに送る．
4. クライアントは認可コードとリダイレクトURIを認可サーバに送る．
5. 認可サーバがクライアントを認証し，認可コードとリダイレクトURIを検証してアクセストークンをクライアントに送る．

ここで認可コードは一時的に生成されたランダムな数値で，有効期間は典型的には10分など．かつてはステップ3で認可コードではなく直接アクセストークンを返してそれで終わりという **インプリシットグラント** (implicit grant) という方法もあったが，安全性に問題があるため今では非推奨．


## 4 古典暗号

1970後半から始まった系統だった学問としての暗号を **現代暗号** と呼び，対照的にそれより以前の時代のものを **古典暗号** と呼ぶ．

この節は単にシフト暗号と換字式暗号の紹介．


# 2章

## 5 アルゴリズム

流石に知っていることしかないので飛ばす．


## 6 安全性

これも時間計算量などほぼ知っていることなので以下だけメモ：

- 秘密鍵のビット長を **鍵長** と呼ぶ．
- 暗号を解読するのに必要な時間計算量などのコストを **セキュリティパラメータ** と呼ぶ．
- 或る暗号に於いて，n ビットのデータに対する総当たりしか攻撃方法が知られていない場合，その暗号は **n ビットセキュリティ** であるという．


## 7 暗号技術の危殆（キタイ）化

### コンピュータの性能向上と暗号の安全性

各暗号で128ビットセキュリティを達成するために必要な鍵長：

- 共通鍵暗号： 128ビット
- ハッシュ関数： 256ビット
- RSA暗号： 約3000
- 楕円曲線暗号： 256ビット

2020年には鍵長800ビットのRSA暗号が破られており，1024ビットも1年ほどスーパーコンピュータを回せば破れると推測されるため2048ビット以上が推奨されている．


### 運用監視暗号リストと推奨暗号リスト

国内ではCRYPTECが運用監視暗号リストと推奨暗号リストを後悔している．前者は互換性維持以外を目的としての使用を推奨しないもの．


### 危殆化の問題点

現在インターネットで使用されている暗号はおそらく2030年を超えても当面は安全だろうとされているが，半世紀後もそうかはわからない．

ゲノムのような，漏洩すると子孫にも永久に影響が残るような情報はとりわけ取り扱いが難しい．少なくとも現時点では残念ながら未来永劫安全になるように大きなデータを手元の小さい鍵で暗号化しておく方法は存在していない．


# 3章 共通鍵暗号

## 8 共通鍵暗号

### 共通鍵暗号とは

暗号化に使う鍵（＝秘密鍵）と復号に使う鍵が同じである暗号方式を **共通鍵暗号**（または **秘密鍵暗号** や **対称鍵暗号**）と呼ぶ．これを使う場合，暗号化する人と復号する人で事前に秘密鍵を共有し他者には漏らさないようにしなければならない．


### 共通鍵暗号に求められる安全性

厳密な定義は難しいので概略を示す：

- 強秘匿性：
  + 暗号文から平文を一部でも推測するのが困難なこと．
  + 例えば平文を少し変えただけで暗号文が全く異なるものとなるなど．
- 選択平文攻撃への耐性：
  + `(平文, 暗号文)` の組がいくつか盗聴によって漏れたとしてもそれを一般の暗号文の解読に利用するのは困難であること．
  + このような盗聴は通信されるデータのヘッダに平文の一部が漏れていたりすることなどによって起きることが想定される．
  + ほかにも **選択暗号文攻撃**（**CCA**，→p.117）を想定することもある．


### 共通鍵暗号の種類

共通鍵暗号は **ブロック暗号** と **ストリーム暗号** に大別される．ブロック暗号は平文を複数のブロックに分割してブロックごとに暗号化する．ストリーム暗号は乱数によってノイズを生成しそれと平文を混ぜて暗号化する．


## 9 ビットと排他的論理和

これも流石に知っているが，以下だけ重要：

```
(a xor b) xor b = a
```

証明は `xor` の結合律から従う：

```
(a xor b) xor b
  = a xor (b xor b)
  = a xor 0
  = a
```

`a` を暗号文，`b` を秘密鍵とみなすとよい．


## 10 乱数

### 真の乱数

“次にどんな値になるか予測できない数列” を **乱数列** といい，乱数列のそれぞれの値を **乱数** と呼ぶ．

真の乱数は，一度得られた乱数列の全部またはそれに等価なデータを記録しておかない限り復元することはできないという意味で **再現不可能性** をもつという．


### コンピュータで扱う乱数

通常のソフトウェアで再現不可能な乱数を生成するのは難しいため，乱数列を生成する専用のハードウェアが開発されている．ただし，乱数生成用ハードウェアはブラックボックスなのでベンダが制御している可能性も排除はできないし，不具合で乱数になっていない可能性もある．実際2019年7月にはAMDのCPUに乱数生成命令が固定値を返す場合がある不具合が発見されたし，2020年6月にはIntelのCPUに於いて乱数生成命令が生成した乱数を他のプロセスから盗み見る攻撃手法が発見された．Linuxの `/dev/random` はハードウェアだけでなく様々なデータも組み合わせて使っており，どれか1つに問題があっても最終的な出力には問題がないように実装されているらしい．


### 擬似乱数

**シード** (seed) と呼ばれる初期状態をもとに，あるアルゴリズムによって一見真の乱数に見えるような列を出力する方法があり，このようなアルゴリズムないし装置を **擬似乱数生成器** といい，これに生成された列を **擬似乱数列** と呼ぶ．擬似乱数列はシードが決まれば列は変わらないため，再現不可能性はもっていない．

擬似乱数はシードさえ漏洩しなければ乱数のように扱える．

Linuxの `/dev/urandom` は擬似乱数生成器．


### 擬似ランダム函数

**シード** と任意の整数を受け取って乱数を出力する函数を **擬似ランダム函数** (pseudorandom function, PRF) と呼ぶ．気持ちとしてはシードを部分適用すると乱数を返す函数が得られるという具合．

擬似乱数生成器があれば擬似ランダム函数が構成できることが知られている．

> 疑問： 自然に考えると単に擬似乱数の列をそのまま添字アクセスすることで確かに擬似ランダム函数にできるが，これはかなりパフォーマンスが悪いはずで，第2引数に対して線型時間かかる．もっとパフォーマンスが良い構成方法があるのかも？


## 11 ワンタイムパッド

実用には即さないが，平文 `m` に対して毎回その平文と同じビット長の秘密鍵 `s` を生成して暗号化に使う **ワンタイムパッド** (one-time pad, OTP) という方式は **情報論的安全性** を満たすことが知られている．

暗号化と復号化の方式としては単にbitwiseに排他的論理和を取るだけ：

```
Enc(s, m) := m ⊕ s
Dec(s, c) := c ⊕ s

Dec(s, Enc(s, m)) = (m ⊕ s) ⊕ s = m
```

“秘密鍵 `s` の生成に偏りがなければ暗号文には一切秘密鍵の情報が漏れない” という点で情報理論的に安全で，全探索よりも良い攻撃方法がない．


## 12 ストリーム暗号

ワンタイムパッドをもう少し実用に即したものにするために，“ワンタイムパッドの秘密鍵に使う乱数を擬似乱数に置き換えた変種” を考える．こうすれば，擬似乱数を生成するシードだけを秘密鍵として最初に共有すればよいので，秘密鍵のサイズが減る．こうした方式を **ストリーム暗号** と呼ぶ．76ページの図を参照．

ただし，ここでシードを “もともとの秘密鍵” よりも真に短くしたことにより，情報論的安全性は満たさなくなる．というのも，シードが `n` ビットなら擬似乱数列は高々 `2^n` 種類しかないため．

> 疑問： ここの書籍での説明は若干変な気がする？ 原理的には，擬似乱数列として出ないパターンがある（例えば，長さ `n` の10ビット値の列は `(2^10)^n` 通りあるが，シードが8ビットならそのうちの `2^8` 通りしか出ない）のであって，単一の擬似乱数として出ない値があるというわけではないはず．

しかし，それでもシードに対する全探索以上によい解読方法がなければ `n` ビットセキュリティを達成することができ，現在は `n = 128` 程度で安全であろうとされている．こうした安全性の考え方を **計算量的安全性** と呼ぶ．


### ナンス

シードが同一なら同一の擬似乱数列が生成されるので，1つのシードは1回しか使えない．これは不便なので，擬似乱数列の生成にシードとは別に **ナンス** (nonce) という値を入力できるようにし，ナンスを通信ごとに毎回変えることによってシードを繰り返し利用できるようにするという方式が採られたりする．“従来のシードをナンスと新しい固定できるシードから生成できるようにする” 方式とも言えそう．


### ChaCha20

**ChaCha20** は，D. J. Bernsteinによって2008年に開発された，256ビットの秘密鍵と96ビットのナンスを元に512ビットずつの擬似乱数列を生成するストリーム暗号．ChaCha20で用いられている擬似ランダム函数は **4分の1ラウンド函数** と呼ばれる函数を使っている．まず最初に固定の定数128ビット，秘密鍵256ビット，カウンタ32ビット，ナンス96ビットの合計512ビットを32ビット整数16個に分けて4×4の正方形に配置し，これに対して1/4ラウンド函数という “かき混ぜ処理” を8回1セットとして10セット適用し，最終的に得られた512ビットを出力乱数とするというもの．カウンタは単に 1, 2, 3, … とインクリメントするだけ．

1/4ラウンド函数の定義は80ページ参照．


## 13 ブロック暗号

平文を **ブロック** と呼ぶ一定の長さごとの単位に切り分け，そのブロックごとに暗号化する方式を **ブロック暗号** と呼ぶ．分割時に端数があれば，残りの部分をパディングで埋めてそれを最後の1ブロックとする．各ブロックがどう暗号化されるかはいくつかの方法があり，この方法を **暗号化モード** という．

かつては1970年代に開発された **DES** (Data Encryption Standard) というブロック暗号がよく使われていたが，ブロックサイズ64ビット，鍵長56ビットと短いのが欠点で，1990年代には1日未満で解読できることが報告された．そのため，代替となる **AES** (Advanced Encryption Standard) が公募により開発された（AESの採用が確定するまでは，DESを3回重ねて暗号化した **3DES** をその場しのぎ的に使用された）．最終的にRijmenとDaemenによるRijndaelという暗号方式がAESに選ばれ，現在に到るまで広く使われている．


AESのブロックは128ビットで，鍵長は128ビット，192ビット，256ビットから選べる．

AESの暗号化は，秘密鍵に応じた初期化の後，**ラウンド函数** と呼ばれる処理を繰り返すもの．繰り返し回数は鍵長に応じて異なり，長い鍵ほど多く繰り返すので計算時間がかかる．

上限としては128ビットセキュリティで，現在のところ126.1ビットセキュリティで解読できることが示されているが，それでも十分安全である．

処理の流れ図は84ページ参照．ラウンド函数はやはり128ビットのデータを4行4列に並べて換字表の表引き，位置ずらし，8ビットの体での行列演算を適用する（復号はこれの逆にあたる操作を行なう）．ただし，最後のラウンドは行列演算だけやらない．

AESの処理は，ソフトウェアではなくハードウェア的に高速に行なうために，**AES-NI** (NI = New Instructions) と呼ばれるAESの高速処理用の専用命令がCPUに搭載されている．


## 14 確率的アルゴリズム

秘密鍵を共有するコストは高いので，通常秘密鍵が1度決まるとしばらくは使い回される．だが，それゆえに同じ平文が毎回同じ暗号文になると，1箇所平文を推測できると他の同一の暗号文の出現が全部解読できてしまうのでまずい．そこで，同一の平文に対してもできるだけ毎回異なる暗号文になるようにしたい．すなわち，乱数によって毎回出力が違っており，かつそれでも復号できるような確率的アルゴリズムを採用するのが望ましい．

例えば，ブロック暗号の暗号化モードのうち，**ECBモード** は同一の平文に対して同一の暗号文を返す決定的アルゴリズムであり，これは元の情報が漏れてしまうので安全ではない．一方，**CBCモード** という暗号化モードはこの確率的アルゴリズムになっている．


## 15 暗号化モード

**ECBモード** (ECB = Electronic CodeBook) は，前節で述べたように決定的アルゴリズムで，単に平文のブロック（と秘密鍵）を受け取って暗号文のブロックを出力するという操作をブロックごとに行なうもの．繰り返しになるがこれは安全ではないので使ってはいけない．

**CBCモード** (CBC = Cipher Block Chaining) は，最初に **初期化ベクトル** (initialization vector, IV) というブロックと同じ長さの値を乱数で生成して使う．IVは暗号文と一緒に渡すので公開されるが，予測できないランダムな値．IVを `IV`，平文の各ブロックを `m_i` として，暗号文のブロック `c_i` は次のように得る：

```
c_1 := Enc(m_1 ⊕ IV)
c_i := Enc(m_i ⊕ c_(i - 1))  (i > 0)
```

すなわち，或るブロックを暗号化した結果がその次のブロックの暗号化の前に排他的論理和をとるのに使われる．こうして各ブロックの内容が同じだったとしても暗号化されたブロックが一般には毎回異なるようになっている．


### CTRモード

**CTRモード** (CTR = CounTeR) は，ブロック暗号を使って擬似乱数を生成し，これをストリーム暗号として使用するというモード．`M_i` を前半がナンス，後半がインクリメントされるカウンタからなる値とし，これを平文としてブロック暗号で暗号化した `C_i` をストリーム暗号の乱数として使用するのである．最終的な暗号文のブロック `c_i` はこの `C_i` と本当の平文 `m_i` を用いて `c_i := C_i ⊕ m_i` とする．各 `M_i` は必ず異なるので，CTRモード中で使うブロック暗号はECBでもよい．


### CBCモードとCTRモードの比較

CBCモードはブロック間に依存があるため，前のブロックからシーケンシャルに構成しなければならないが，CTRモードは `C_i` をつくるために各ブロックを独立に暗号化してよいので並列処理できて高速化が期待できる．


### CBCモードに対する攻撃

CBCモードはSSL/TLSで広く使われていたが，2011年の **BEAST攻撃** を皮切りにいくつかのCBCモードに対する攻撃手法が発見され，2014年の **パディングオラクル攻撃** (**POODLE**) によりCBCモードの脆弱性は決定的なものとなった．これによりSSL3.0が廃止された．


## 16 ディスクの暗号化

### TPM

PCやスマートフォンなどのデバイスには，**TPM** (trusted platform module) と呼ばれるセキュリティ専用チップが組み込まれている．これにより暗号化，復号化，署名の生成や検証ができるほか，OSの起動時にシステムが改竄されていないかどうかも確かめられる．

HDDやSSDといったストレージを暗号化する場合，ファイル単位ではなくストレージ全体を暗号化する方法がOSの標準機能として搭載されている．これにより，万が一他人がディスクを取り出して他のマシンに接続しても中身が見られないようにできる．ただし，マシンが壊れた場合にはストレージの内容を復旧するのに秘密鍵が必要になる．この秘密鍵は厳重に管理しなければならない．


### ディスクの構造

ストレージに対する読み書きは **ブロック** という一定サイズを単位として処理される．ここではブロック暗号化のブロックと混同をきたさないために **データユニット** と呼ぶことにする．


### XTS-AESの概要

2004年にP. Rogawayにより暗号化モード **XEX** が提案され，**XTS** がそれを元にして提案された．**XTS-AES** はブロック暗号AES（→ 「13 ブロック暗号」参照）を使用した暗号のひとつで，WindowsのBitLocker，macOSのFileVault2，Linuxのdm-cryptといったディスク暗号化ソフトウェアで利用されている．

XTS-AESはAESの鍵長のビット列 `K_1`，`K_2` の2個を秘密鍵とする．これのほかに **tweak** と呼ばれる値 `T` も使ってデータユニットの暗号化を行なう．ディスク暗号化に於いては，tweakにはデータユニットの番号が使われる．tweakはナンスとは異なり同じ値が再利用されても危険ではないとされる（後述）．


### XTS-AESの暗号化

平文であるデータユニットを `n` 個のブロック `m_1`，…，`m_n` に分割する．また，`α^i` を `i` 次多項式 `x^i` に対応する拡大体 `F_{2^128}` の元とし，`⊗` を `F_{2^128}` の積とする．各ブロックの暗号化 `C_i` を以下により得る：

```
S_i := Enc(K_1, T) ⊗ α^n
C_i := Enc(K_2, S_i ⊕ m_i) ⊕ S_i
```

流れ図は98ページの図を見るべし．


### XTS-AESの安全性

tweakは同一データユニット内では同じ値を使い回すので，同じ平文に対して同じ暗号文が得られることになり，一見危険そうに思えるが，少なくとも暗号文から平文を解読するのは容易ではないと考えられている．安全性のためデータユニットのブロックは `2^20` 以下のサイズでないといけないとNISTによって注意されているが，通常データユニットがそんなに大きい単位に分割されることはない．


### 自己暗号化ドライブ

SSDやHDDの中にはハードウェアで暗号化・復号化を行なう仕組みをもつものがあり，これを **自己暗号化ドライブ** (**SED**, self-encrypting drives) と呼ぶ．SEDはソフトウェアの水準によるディスク暗号化に比べると扱いが容易でCPUのリソースを消費しないという利点があるが，PCの電源投入中やスリープ中に秘密鍵を狙った攻撃ができる可能性が知られている．


## 暗号文の改竄とリプレイ攻撃

CBCモードやCTRモードで見たように，同一の平文から毎回異なる暗号文が得られれば安全性が増すが，それだけでは不十分である．


### 暗号文の改竄

攻撃者が暗号文を改竄することができる状況を考えると，受信者の手元で送信者が意図しない平文に復号化されてしまうという攻撃が成立するリスクがある．したがって，暗号文のまま容易には改竄できないようにしなければならない．「28」や「38」で後述．


### リプレイ攻撃

攻撃者が（暗号文の中身がわからなくても）何度も同一の暗号文を（送信者になりすまして）送るという攻撃が成立するリスクがある．したがって通し番号や識別子を与えて同じ送信が繰り返されていないかチェックしなければならない．


# 4章 公開鍵暗号

## 18 鍵共有

### 現代暗号の始まり

共通鍵暗号では，送受信し合う2者の間で秘密鍵を共有する手段に乏しいのが難点だったが，1970年代に鍵共有・公開鍵暗号・署名の概念が提案され，現代暗号の技術の開始点となった．有名なのは1976年のDiffieとHellmanによる提案だが，1975年のMerkleが鍵共有を提案してその先鞭をつけていたほか，1997年にイギリスのGCHQが公開した資料によると1970年前後には既に内密に鍵共有・公開鍵暗号・RSA暗号が発見されていたらしい．


### 冪乗

鍵共有には冪乗の性質 `(g^a)^b = (g^b)^a` が活かされる．より正確には，その剰余である `(g^a)^b mod n = (g^b)^a mod n` が活用されている（もっと言えば，剰余をとる操作は積と可換なので，“計算途中の好きなタイミングで剰余を取ってよい” ことが活かされている）．


### Diffie-Hellman鍵共有

以下のような仕組みでAliceとBobの間で秘密鍵を共有する手法を **Diffie-Hellman鍵共有**（DH鍵共有）という：

1. AliceとBobで `g` と `n` を決めて固定する（`g` と `n` は公開状態で共有し，したがって漏洩してよい）．
2. Aliceは秘密の値 `a` を決め，`A := g^a mod n` を算出してBobに送る（`A` は漏洩してよい）．
3. Bobも秘密の値 `b` を決め，`B := g^b mod n` を算出してAliceに送る（`B` は漏洩してよい）．
4. Aliceは受け取った `B` を用いて `s := B^a mod n` を算出する．
5. Bobは受け取った `A` を用いて `s' := A^b mod n` を算出する．

このとき冪乗の性質より `s = s' = g^{a・b} mod n` が成り立ち，これが共有された秘密鍵として使える．


### DH鍵共有の安全性

前節の手順が安全であるためには，以下の問題（**Diffie-Hellman Problem**，**DHP**）が計算量的に難しい必要がある：

> `g`，`n`，`g^a mod n`，`g^b mod n` の値がそれぞれ判っているとき，`g^{a・b} mod n` を求めよ．

現在のところ，`n` が2048ビット以上（十進数で600桁以上程度）の素数でいくつかの条件を満たせば今後20年間に登場するどんな計算資源を以てしても解けないだろうと予測されている．


### DLPと一方向性函数

もし以下の問題（**離散対数問題**，**DLP**）が計算量的に簡単に解けるなら，DHPも系として簡単に解ける：

> 与えられた `g`，`n`，`A` に対し，`A = g^a mod n` なる `a` を求めよ．

この問題は，`g` と `n` を固定した下で，`a` から `A` を得るのは簡単だが `A` から `a` を得るのは難しいという非対称性を有する．こうした変換 `a ↦ A` を（フォーマルな定義を与えるわけではないが，ここでは）**一方向性函数** と呼ぶ．


### 冪乗の計算方法

`n` 乗は自明な方法により `O(log n)` と対数時間で計算できる．


## 19 有限体と拡大体

### 有限体

集合 `S := {0, 1, 2, …, n - 1}` に，まず乗算して `mod n` をとる演算を入れる．この代数系で除算は定義できるだろうか？ →実は任意の `n` で除算が定義できるわけではないことが知られている．例えば `n = 6`，`n = 12` は存在しない．しかし，`n = p` が素数の場合は必ず除算が定義できることがわかっており，こうして除算を定義してできる体を **有限体** と呼び，`F_p` と書く．


### 拡大体

`F_2` は台集合が `{0, 1}` で積が連言，和が選言に相当するような有限体である．これを “多項式に拡張したもの” がここでいう **拡大体** である．すなわち，例えば “2ビットの拡大体” は `00`　が `0`，`01` が `1`，`10` が `x`，`11` が `x + 1` に相当し，まず以下のように加算が定義できる（これは単に “繰り上げなどがないビットごとの加算”）：

|     `+` |     `0` |     `1` |     `x` | `x + 1` |
|---------|---------|---------|---------|---------|
|     `0` |     `0` |     `1` |     `x` | `x + 1` |
|     `1` |     `1` |     `0` | `x + 1` |     `x` |
|     `x` |     `x` | `x + 1` |     `0` |     `1` |
| `x + 1` | `x + 1` |     `x` |     `1` |     `0` |

乗算は少し非自明で，天下り的だが `x^2 = x + 1` とするとうまく定義できる（すなわち，`0` 以外の元に逆元が一意的に存在して除算が定義できるなどし，有限体となる）：

|     `⊗` |     `0` |     `1` |     `x` | `x + 1` |
|---------|---------|---------|---------|---------|
|     `0` |     `0` |     `0` |     `0` |     `0` |
|     `1` |     `0` |     `1` |     `x` | `x + 1` |
|     `x` |     `0` |     `x` | `x + 1` |     `1` |
| `x + 1` |     `0` | `x + 1` |     `1` |     `x` |

直観としては `x * (x + 1) = x^2 + x = (x + 1) + x = x + x + 1 = x` といった具合．

ちなみに，8ビットの場合はやはり天下り的だが `x^8 = x^4 + x^3 + x^2 + 1`，128ビットの場合は `x^128 = x^7 + x^2 + x + 1` とすることで有限体 `F_{2^8}` および `F_{2^128}` が定義できる．


## 20 公開鍵暗号

### 公開鍵暗号の概念

共通鍵暗号は物理的な錠に対する鍵のように暗号化と復号化に同一の鍵を用いるのに対し，**公開鍵暗号** では暗号化には誰に知られてもよい **公開鍵** を，復号化には自分しか知らない秘密鍵を用いる．

大抵の共通鍵暗号の方式では，公開鍵は秘密鍵からつくるが，秘密鍵から公開鍵をつくることは容易ではないという非対称性を実現する．

公開鍵暗号は，**鍵生成**，暗号化，復号化という3つのアルゴリズムからなる．

* 鍵生成：
  - Bobは秘密鍵 `b` と公開鍵 `B` の組 `(b, B)` を生成し，公開鍵 `B` だけを全員に公開する．Aliceは `B` を受け取る．これは1度だけ行なえばよい．
* 暗号化：
  - AliceはBobから受け取った `B` で平文 `m` を暗号化し，暗号文 `c := Enc(B, m)` をつくり，Bobに送る．
* 復号化：
  - Bobは受け取った `c` に対し，自身の秘密鍵 `b` を用いて復号化する： `m' := Dec(b, c)`．このとき `m' = m` である．


### 共通鍵暗号との違い

共通鍵暗号は相手の数だけ鍵を保管し漏洩しないように努めねばならないが，公開鍵暗号ではどれだけ多くの相手がいても秘匿して保管せねばならないのは自分の秘密鍵だけ，というのも公開鍵暗号のメリット．


### 強秘匿性と頑強性

攻撃者が任意の平文の暗号文を入手できる状況での攻撃を **選択平文攻撃**（**CPA**）というのであった（→ 8）．公開鍵暗号では攻撃者が公開鍵を使って任意の平文を暗号化できるので，このCPAに対して安全でなければならない．

CPAが可能な下では，もし暗号化方式が乱数を使わない決定的アルゴリズムなら安全ではない．というのも，ありえそうな平文の候補が少ない場合，全通り暗号化を試して解読対象の暗号文と一致するものを見つければよいため．それゆえ，公開鍵暗号の方式は乱数に依存しなければならない．

また，パディングオラクル攻撃（→ p.95）のように，自分で選んだ暗号文に対する平文の情報を受け取れる状況も考慮する必要がある．攻撃者が解読対象の暗号文ではない自分で選んだ暗号文の平文を（存在するなら）いつでも入手できる状況下での攻撃を **選択暗号文攻撃**（**CCA**, chosen ciphertext attack） と呼ぶ（→ p.58）．CCAでも特に平文の入手が攻撃対象の暗号文の取得よりも前にだけ行なえる場合を **CCA1**，常に行える場合を **CCA2** と呼ぶ（すなわちCCA2の方が攻撃の条件としては良い）．

以下のようなゲームを考える：

- 攻撃者が2つの平文 `m_1`，`m_2` を選び，相手に渡す．
- 相手はその平文のどちらかを選び，暗号化して暗号文 `c` を攻撃者に返す．
- 攻撃者は `c` がどちらの平文を暗号化したものか当てる．

CPA，CCA1，CCA2の状況下で，“このゲームの正答率が1/2を有意に超えない” 場合，その暗号化方式はそれぞれ **IND-CPA安全**，**IND-CCA1安全**，**IND-CCA2安全** であるという（INDはindistinguishabilityの略）．

IND-CCA2安全な公開鍵暗号方式は，暗号文から平文の情報が少しも得られないことを指す **強秘匿性** という性質を満たすことが知られている．

また，平文の情報が得られなくても暗号文の少し弄って平文を操作するという改竄の攻撃（→ p.100）ができない場合，その暗号化方式は **頑強性** をもつというが，IND-CCA2安全な公開鍵暗号方式は頑強性も満たすことが知られている．


### ハイブリッド暗号

多くの場合，公開鍵暗号を素直に実装すると共通鍵暗号に比べてかなり速度が遅い．そこで，公開鍵暗号の利便性と共通鍵暗号の速度を両取りした **ハイブリッド暗号** を使う．ハイブリッド暗号は，共通鍵の秘密鍵（典型的には256ビット程度と小さい値）だけを公開鍵暗号で共有し，この共有を前提として共通鍵暗号を暗号化と復号化に用いるというもの．この方法の前半を **鍵カプセル化メカニズム**（**KEM**，key encapsulation mechanism），後半を **データカプセル化メカニズム**（**DEM**，deta encapsulation mechanism）と呼び，この方法全体を **KEM-DEMフレームワーク** と呼んだりする．


## RSA暗号

**RSA暗号** は，RivestとShamirが1977年に提案した公開鍵暗号で，Diffie-Hellman鍵共有のような冪乗のmodがもつ性質を利用した暗号化方式．

- 2つの相異なる素数 `p`，`q` を選ぶ．
- `n := p q`
- 正整数 `e` を1つ選ぶ．`e := 65537` とすることが多い．
- `e d mod (p - 1) (q - 1) = 1` なる整数 `d` を探す（これは比較的簡単なアルゴリズムで求まる）．
- `(n, d)` を秘密鍵とし，`(n, e)` を公開鍵とする．
- 暗号化： `Enc((n, e), m) := m^e mod n`
- 復号化： `Dec((n, d), m) := c^d mod n`

暗号化と復号化が “同一の函数” で表されるのはRSA暗号特有の性質．

復号化で平文が元に戻ること，すなわち `(m^e mod n)^d mod n = m` が成り立つことは，Formatの小定理によって示せる．

> Fermatの小定理： `p` を素数，`a` を `p` の倍数でない整数とすると，`a^{p - 1} ≡ 1 (mod p)`．

『暗号と認証』には載っていないが，証明してみる（おそらく平文 `m` に何らかの仮定があるので適宜補う）：

`e d = D (p - 1) (q - 1) + 1` とすると，

```
(m^e mod n)^d mod n = m
<==> ((m^e)^d mod n) mod n = m  (∵冪乗とmodは交換可能)
<==> m^{e d} mod n = m
<==> ∃N. m^{e d} = m + n N
<==> ∃N. m (m^{e d - 1} - 1) = p q N
<=== ∃N. m (m^{D (p - 1) (q - 1)} - 1) = p q N
```

より，`m^{D (p - 1) (q - 1)} - 1` が `p q` の倍数であることを示せばよい．**`m` が `q` の倍数ではないとすると**，`q` は素数であるため `m^{D (p - 1)}` は `q` の倍数ではなく，したがってFermatの小定理より

```
m^{D (p - 1) (q - 1)} - 1 = (m^{D (p - 1)})^{q - 1} - 1 ≡ 0 (mod q)
```

であり，`m^{D (p - 1) (q - 1)} - 1` は `q` の倍数．同様にして **`m` が `p` の倍数ではないとすると** Fermatの小定理より `m^{D (p - 1) (q - 1)} - 1` は `p` の倍数．■


### RSA暗号の安全性

`n := p q` が十進数で600桁以上であるように `p` と `q` を選ぶと，公開鍵 `(n, e)` と暗号文 `c` から元の平文 `m` を現在の計算機によって現実的な時間で求めることは不可能と考えられている（**RSA仮定**）．もし `n` が高速に `p` と `q` に素因数分解できると，それによって秘密鍵の `d` が簡単に得られるのでRSA仮定は破れてしまう（すなわち，RSA仮定は素因数分解よりは易しい）のだが，今のところそのような方法は知られていない．

`Enc((n, e), _) : m ↦ c` はその逆向きの変換 `c ↦ m` が難しいため一方向性函数と言えるが，`c` に加えて `d` にあたる値がわかっていると簡単に求められるので，このことを指して **落とし戸つき一方向性函数** (trapdoor function) と言ったりする．

なお，ここで述べたRSA暗号はそのままの形だと決定的アルゴリズムなので公開鍵暗号として使ってはいけない．また，特に平文 `m` が `0` や `1` の場合は冪乗しても全く値が変わらない．実際の暗号では，ここで述べたRSA暗号の定式化をもとにより安全にした方式が使われている．


## 22 OpenSSLによるRSA暗号の鍵の作り方

以下で2048ビットの秘密鍵 `sec-test-key.txt` が生成される：

```console
$ openssl genrsa 2048 > sec-test-key.txt
```

次に秘密鍵を使って以下を行なうと対応する公開鍵 `pub-test-key.txt` が生成される：

```console
$ openssl rsa -pubout < sec-test-key.txt > pub-test-key.txt
```

これらの秘密鍵と公開鍵はBase64でエンコードされている．以下で公開鍵のhexdumpとExponent（上記の `e` のこと）を表示してくれる：

```console
$ openssl rsa -text -pubin -noout < pub-test-key.txt
```

秘密鍵も同様に以下で確認できる：

```console
$ openssl rsa -text -noout < sec-test-key.txt
```


## 23 楕円曲線暗号

### 楕円曲線

**楕円曲線** とは，`p` を素数として，`(0, 0)` から `(p - 1, p - 1)` までの格子点がトーラス状に並んだ構造の代数系のことらしい．整数 `a`，`b` を固定して以下のように定義した `E` でも等価らしい：

```
E := {(x, y) ∈ (F_p)^2 | y^2 = x^3 + a x + b } ∪ {O}
```

`E` 上での演算は，`F_p` の四則演算を用いて以下で定義するらしい：

```
-O := O
-(x, y) := (x, -y)
v + O := v
O + v := v
(x_1, y_1) + (x_2 + y_2) := O (if x_1 = x_2 ∧ -y_1 = y_2), (x_3, y_3) (otherwise) where
  x_3 := λ^2 - (x_1 + x_2),
  y_3 := -λ (x_3 - x_1) - y_1,
  λ := (y_2 - y_1) / (x_1 - x_2) (if x_1 ≠ x_2), (3 x_1^2 + a) / (2 y_1) (otherwise)
```

こうして定義すると，任意の点 `v` を何倍かすると `O` になるという性質を満たすらしい．


### ECDHPとECDLP

- **ECDHP**：
  + 楕円曲線 `E` に於いて，`P, a P, b P ∈ E` がわかっているときに `a b P` を求めよ．
- **楕円離散対数問題**（**ECDLP**）：
  + 楕円曲線 `E` に於いて，`A, P ∈ E` が与えられたときに `A = a P` なる `a` を求めよ．

これらの問題も，離散対数問題と同様に「楕円曲線では整数倍は簡単だが逆は難しい」という一方向的性質により難しい．


### ECDH鍵共有

楕円曲線を用いたDH鍵共有が **ECDH鍵共有**．あらかじめECDHPを解くのが難しい楕円曲線 `E` とその点 `P ∈ E` を定めておいて，以下を行なう：

1. Aliceは自分だけの秘密の値 `a` を決め，`A := a P` を公開する．
2. Bobも秘密の値 `b` を決め，`B := b P` を公開する．
3. AliceはBobが公開した `B` を用いて `s := a B` を使う．
4. BobはAliceが公開した `A` を用いて `s' := b A` を使う．

こうすると楕円曲線でのスカラー倍の可換性により

```
s = a B = a (b P) = (a b) P = b (a P) = b A = s'
```

であり，`s` と `s'` は相等しい．こうして鍵共有ができたことになる．


### 楕円曲線暗号の特長

広義には，楕円曲線を用いた暗号を全般に **楕円曲線暗号** と呼ぶ．

楕円曲線暗号は，RSA暗号や通常のDH鍵共有に比べると，共有される鍵を小さくできるという利点がある．

共通鍵暗号でない暗号は多くの場合総当たりよりも真に早い解読方法があり，一般に `n` ビットセキュリティを達成するには `n` 以上の長さの鍵が必要．RSA暗号について言うと，素因数分解およびDHPは指数時間よりも真に良い（が多項式ではない）時間計算量で解けることが知られており，その影響でRSA暗号で128ビットセキュリティを達成しようとすると数千ビットの秘密鍵が必要になる．

楕円曲線暗号の場合，ECDHPやECDLPはそれほど高速な解放が見つかっておらず，最良でも `O(2^{n/2})` であるため，`n` ビットセキュリティを達成するには `2 n` ビットあれば十分．無論将来的に解読の計算量が改善される可能性もあるが，現在のところ安全．


## 24 中間者攻撃

### ECDH鍵共有への中間者攻撃

鍵共有に対し，以下のような改竄の攻撃を考える：

- Aliceは自分だけの秘密の値 `a` を決め，`A := a P` を公開する．
- Bobも秘密の値 `b` を決め，`B := b P` を公開する．
- **攻撃者は値 `c` を決め，`C := c P` とする．** 勿論 `c` と `C` はおろか自身の存在も公開しない．
- AliceからBobへ `A` が送られる際に，攻撃者が改竄して `C` をBobに送る．
- BobからAliceへ `B` が送られる際に，攻撃者が改竄して `C` をAliceに送る．

すると，AliceとBobは互いの間に鍵共有ができたと思っていながら実はAliceと攻撃者，および攻撃者とBobの間でそれぞれ鍵共有ができていて，攻撃者はAliceとBobから来る暗号文を（それぞれBobとAliceにそのまま転送しつつも）全部復号して読めてしまうし，AliceとBobはその盗聴に気づけない．

こうした攻撃を **中間者攻撃**（**MITM**，Man-In-The-Middle）と呼ぶ．これはECDH鍵共有に限らず鍵共有一般で起こりうる（対処法は → 33）．


# 5 認証

## 25 ハッシュ函数

ここでいう **ハッシュ函数** とはあの通常のハッシュ函数に特定の性質を要請した **暗号学的ハッシュ函数** のこと．

データのハッシュ値は認証に使える．ただし，データは複製できるので，複製できないことを前提とした生体認証での指紋などのようにハッシュ値単体を認証に使用するわけではない（→ 29）．

暗号学的ハッシュ函数には以下の性質が求められる：

- ハッシュ値の出力サイズが一定．
- 一方向性をもつ．すなわちハッシュ値から元のデータを見つけるのが難しいこと．
- **衝突困難性** をもつ．すなわち同一のハッシュ値に写される相異なるデータを見つけるのが難しいこと．

**SHA-256** は256ビットのハッシュ値で，`2^256` 種類の値しかとり得ないから，それ以上に多様なデータを入れれば確実に衝突が起きる．

衝突困難性より弱い概念として「或るデータが与えられた時に，そのデータのハッシュ値と同一のハッシュ値をもつ別のデータ（＝第二原像）を見つけるのが難しいこと」を表す **第二原像計算困難性** がある．衝突困難性と第二原像計算困難性の違いはいわゆる誕生日パラドックスがアナロジーとしてわかりやすく，前者は「クラスに誕生日が同じである2人がいないこと」，後者は「クラス内に自分と同じ誕生日の人がいないこと」に相当する（ちなみに40人のクラスだと前者は11%ほど，後者は90%ほど）．すなわち，衝突を見つける方が第二原像を見つけるより簡単．

* 疑問： 元の本には「ハッシュ値が `n` ビットの場合，第二原像計算困難性を破る問題（すなわち，或る `c` を固定して `h(c) = h(c')` なる `c'` を見つける問題）は総当たりで `O(2^n)` で見つかる」という旨の記載があるが，本当か？ `2^n` 個見ても相異なるハッシュ値になるわけではない（`c` とは無関係なハッシュの衝突が見つかりうる）ので，`n` では上から抑えられないように思える．

衝突困難性を破るのに必要なコストは，慣習的に “`N` 種類のデータから `M` 種類取り出してハッシュ値が一致するものがある確率が0.5を超えた場合” は破られたと判断することにすると，`M ≒ √N` であり，これゆえに `O(2^{n/2})` と見積もられる．よってハッシュ値が256ビットの場合は128ビットセキュリティと見積もれる．


### ハッシュ函数の歴史

- **MD5**： 1992年に規格作成，2004年に衝突困難性が破られる
- **SHA-1**： 1995年に規格作成，2017年に衝突困難性が破られる
- **SHA-256**： 2002年に規格作成，現在のところ脆弱性見つかっておらず


### パスワードとハッシュ函数・パスワードの安全な保存方法

パスワード `m` を元の形がわからないようにと単にパスワードのハッシュ値 `h(m)` をとって保管しておくだけでは攻撃に脆弱であることに注意．人間が設定する弱いパスワードはせいぜい数十万種類程度で，これらのハッシュ値を事前に求めておくと，攻撃者がハッシュ値を漏洩により入手できた際に照合してパスワードを得られてしまうおそれが十分ある（要するに **辞書攻撃**）．特に **レインボーテーブル攻撃** という効率的な攻撃方法も知られている．

対策としては，（セキュリティ対策としてよく知られているように）**ソルト** と呼ばれるユーザごとに異なる乱数 `r` を発行し，このソルトとパスワードの結合のハッシュ値 `h(r ++ m) =: c` をとって `(r, c)` を保存しておくと，よく知られたハッシュ値が現れることはなくなり，マシになる．また，レインボーテーブル攻撃に対する耐性もできる．

- 疑問： `(r, c)` が漏洩したら結局典型的なパスワードの総当たりはできてしまうのではないか？


### ファイルのパスワード暗号化

よく揶揄される **PPAP**（パスワードつきzip送信-パスワード送信 暗号化プロトコル）の何が問題か：

- もしメールが盗聴されていることを想定しているなら，同一経路で2回送信すればいずれも盗聴できるはずなので，全く意味がない．
- ファイルが漏洩した場合の対策であるなら，人力で打てるほどの短いパスワードをつけても安全ではないし，またファイルがウイルスやマルウェアに感染していないかの監査ができなくなるという弊害もある．


## 26 SHA-2とSHA-3

（興味が出たときに読めばよさそう）


## 27 SHA-1の衝突

（興味が出たときに読めばよさそう．SHA-1のハッシュ値が衝突するPDFファイル2個を構成した話など．）


## 28 メッセージ認証符号

**MAC**（**メッセージ認証符号**）とは，データが書き換えられたり壊れたりしていないことを表す性質である **完全性** (integrity) を保証するための仕組み．

### MACのアルゴリズム

MACは，送ったデータの完全性を示したいAliceと，受け取ったデータの完全性を確認したいBobの間で使う．

- 初期化： AliceとBobは事前に秘密鍵 `s` を共有しておく．また，MAC生成函数 `MAC` を決めておく．
- MAC生成： Aliceは送信するデータ`m`と秘密鍵 `s` から **MAC値**（または **認証子** とか **タグ** ともいう）`t := MAC(s, m)` をつくり，`(m, t)` をBobに送る（ここでは `m` の秘匿は簡単のため考えない）．
- 検証： Bobは `(m, t)` を受け取り，`t' := MAC(s, m)` を計算する．`t = t'` ならば正常な受信，そうでないなら不正なデータとして拒否する．


### 完全性と秘匿性

完全性と秘匿性は，一方が他方をimplyするわけではないことに注意．共通鍵暗号は秘匿性はあるが完全性がなく（つまり平文は読めないが改竄は可能），MACは秘匿性がないが完全性は満たす（つまり改竄はできないが平文は読める）．

これらを同時に充足する方法は **認証つき暗号** の節で後述（→ 38）．


### MACの安全性

MACでは，攻撃者はAliceがBobに送る `(m, t)` が盗聴できる（ここでは平文 `m` が読めてしまうが，`m` の時点で既に暗号化されているなどと考え，簡単のためそれ自体は問題ないとする）．この盗聴内容 `{(m_i, t_i)}_i` を十分多数集めようとも，攻撃者がAliceになりすまして送りたいメッセージ `m_{Eve}` に対応するMAC値 `t_{Eve}` が作れてはならない．これがMAC値に求められる安全性．


### MACの構成法

- **HMAC** (hash-based MAC)： ハッシュ函数に基づいてMAC値を構成する方式．特にSHA-256を使った **HMAC-SHA-256** などがある．
- **CMAC** (cipher-based MAC)： ブロック暗号に基づいてMAC値を構成する方式．

HMAC-SHA-256は以下のような構成：

```
C_1 := 0x363636…36（十六進法で36を32回繰り返した値）
C_2 := 0x5c5c5c…5c（十六進法で5cを32回繰り返した値）

HMAC-SHA-256(s, m) :=
  let h_1 = SHA-256((s ⊕ C_1) || m) in
  SHA-256((s ⊕ C_2) || h_1)
```

ここでハッシュ値を1回ではなく2回とっているのは，1回だと **伸長攻撃** と呼ばれる偽造攻撃に脆弱なため．


## 29 署名

### 紙の署名とデジタル署名

中間車攻撃などによる偽造を防ぐため，或るデータが本当に本人の作成したものであることを保証する仕組みをつくりたい，

直筆による署名は筆跡から本人確認ができるし，複製も難しいが，デジタル署名は簡単にコピーできるので，それを克服する仕組みが必要．


### 署名のモデル

AliceがBobにデータを送り，Bobは受け取ったデータが本当にAliceが作成したものであることを確認したいとする．

1. **鍵生成**： Aliceは **署名鍵** `s` と **検証鍵** `S` の組を作成し，`s` は自身のみに秘匿し，`S` はBobを含め全世界に向けて公開する．
2. **署名**： Aliceは送りたいデータ `m` に対して **署名** `σ := sign(s, m)` を作成し，`(m, σ)` の組をBobに送る．
3. **検証**： Bobは受け取った `(m, σ)` に対して `check(S, m, σ)` が成り立つか判定し，成り立つなら受理，成り立たないなら不正な署名として拒否する．

`m` のサイズによらず署名 `σ` のサイズは一定．

MACの場合と同様に，署名アルゴリズムは「受理されたデータは署名時のデータと同一である」という完全性をもつ．

しばしば署名鍵のことを秘密鍵，検証鍵のことを公開鍵ともいうが，公開鍵暗号の場合とは異なり “暗号化された結果” である署名 `σ` から “平文” である `m` へ “復号” することはできないため別にアナロジーではないことに注意．


### 署名の安全性

MACの場合と同様に，攻撃者は `{(m_i, σ_i)}_i` が盗聴できるので，これらの組の十分多数と `S` を得ても `s` が簡単には推定できないような鍵生成と `sign` と `check` を構成する必要がある．


### MACと署名

MACと署名はよく似ているが，検証時に使う鍵を秘密にしなければならないか否かが違う．MACは事前に共有した秘密鍵 `s` を検証時に使うが，署名は広く公開された `S` を使う．この対応関係は共通鍵暗号と公開鍵暗号の関係に似ている．

| 方式 | 暗号化に使う鍵 | 複合に使う鍵 |
|---|---|---|
| 共通鍵暗号 | 秘密 | 秘密（暗号化に使うものと同一） |
| 公開鍵暗号 | 公開 | 秘密 |

| 方式 | 署名に使う鍵 | 検証に使う鍵 |
|---|---|---|
| MAC | 秘密 | 秘密（署名に使うものと同一） |
| 署名 | 秘密 | 公開 |

また，機能面では，MACは署名と検証が同一の秘密鍵で行なわれるため否認防止機能を持っていない．AliceからBobにかつてデータ `m` が送られたことの証拠としてBobが `(m, t)` を提示しても，Aliceは「それはBobが秘密鍵 `s` を使って `t := MAC(s, m)` で作成したデータだろう」と主張できるため．一方の署名アルゴリズムでは，Bobが `check(S, m, σ)` を満たす `(m, σ)` を持っていれば，（Bobは検証鍵 `S` とデータ `m` から `check(S, m, σ)` を満たす署名 `σ` を構成できないので）それがAliceから過去に送られたものであると証明できる．

この意味で署名はMACの上位互換に見えるが，一般にはMACの方が高速に処理できるので，MACの機能で要件が充足できる場合はMACが使われたりする．


### ECDSA

近年は（公開鍵暗号で有限体から楕円曲線のものへ移行が進んでいるのと同様に）署名アルゴリズムとして楕円曲線を用いた **ECDSA** や **EdDSA**（→ p.219）が用いられることが多くなっている．

ECDSAでは，まず楕円曲線の点 `P` と素数 `q` を `q P = O` なる点として選んでおく．`h` をSHA-256などのハッシュ函数とする．

1. 鍵生成： Aliceが `s` をランダムに選んで署名鍵とし，検証鍵を `S := s P` とする．
2. 署名： Aliceはデータ `m` の署名に際して整数 `k` をランダムに選び，`(r, _) := k P` で `r` を定め，`σ := (r, (h(m) + s r) / k)` として `(m, σ)` をBobに送る．
3. 検証： Bobは `(r, t) := σ` に対して `(r', _) := (h(m) P + r S) / t` を計算し，`r' = r` ならば受理．


### 公開鍵認証

署名の検証鍵（＝公開鍵）を用いて本人確認する方法を **公開鍵認証** と呼び，これはよく知られているように **SSH** などで使われている．`id_rsa` の内容が署名鍵 `s` で，`id_rsa.pub` の内容が検証鍵 `S` である．

AliceがSSHでサーバBobに接続する時，以下のようなことが行なわれている：

1. 鍵生成： Aliceは署名の鍵生成により署名鍵 `s`（＝`id_rsa`）と検証鍵 `S`（＝`id_rsa.pub`）を生成し，`S` をサーバBobに送って登録する．
   - これは1度だけ行なえばよい．
   - `S` は勿論盗聴されてよい．
   - **疑問： しかし，ここで登録する `S` が攻撃者に改竄されるとなりすましのリスクがある？（後でAliceがBobに送信しようとすると検証で拒否されることにより改竄に気づけるが，攻撃者による送信はAlice本人によるものとして検証に通ってしまうはず）**
2. 署名： AliceがサーバBobに接続したい時，DH鍵共有などをもとにして生成された予測できない値（セッション識別子）`v` に対してAliceが署名 `σ := sign(s, v)` を生成し，`(v, σ)` をBobに送る．
3. 検証： Bobは受け取った `(v, σ)` を `S` で検証，すなわち `check(S, v, σ)` が成り立つか否かを判定し，本人確認する．

予測できない `v` を使うのは，攻撃者が `(v, σ)` を登頂してもリプレイ攻撃（→ p.101）ができないようにするため．
