
# 2章 ユーザモードで実現する機能

ユーザモードからカーネルモードの処理が必要なときはシステムコールを介して呼ばれる．

## システムコール

システムコールは以下のような操作を担う：

- プロセス生成/削除
- メモリ確保/解放
- プロセス間通信
- ネットワーク処理
- ファイルシステム操作
- ファイル操作（デバイスへのアクセス）


### CPUのモード遷移

システムコールはCPUの特殊な命令を実行することで発行する．システムコールが発行されると割り込みが発生し，ユーザモードからカーネルモードに遷移して該当する処理が走り，その処理が終わると再びユーザモードに戻る．カーネルモードの開始時にはプロセスからの要求が正当であるかがチェックされ，不正なら失敗させる．（もしプロセス自身がモードを切り替える手段を持っているなら権利の設計としておかしいため，このような仕組みになっている）．


### システムコール呼び出しの様子

`strace -o 〈Log〉 〈Command〉`  で，通常のコマンド `〈Command〉` による処理に対して発行されたシステムコールのログが `〈ログファイル〉` に出力される．例えばHello Worldプログラムでは `write()` が発行されている様子がわかる（ほかにも前後にプロセスの開始処理と終了処理に伴うシステムコールがたくさん発行される）．


### 実験

`sar` コマンドで各CPUコアがユーザモードとカーネルモードのどちらで実行しているかの割合を見ることができる．


### システムコールの所要時間

`strace` の `-T` オプションを使うと各システムコールの処理に何マイクロ秒かかっているのかを出力できる．


## システムコールのラッパー関数

システムコールは（CPUの実装に依存することから）アーキテクチャ依存のアセンブリコードを使って呼び出す必要があり，C言語などの或る程度高級な言語からはこれをラップして “FFI的に” 呼び出せるようにしてある（OSがライブラリを提供している）．


## 標準Cライブラリ

C言語にはISOが定めた標準ライブラリがあり，Linuxもこれに準拠してライブラリを提供している．通常はGNUの `glibc` で，これがシステムコールのラッパーを含む．

プログラムがどんなライブラリをリンクしているかは `ldd` コマンドで確かめることができるので見てみるとよい．


## OSが提供するプログラム

OSはライブラリだけでなくプログラムも提供しており，（よく知っているように）以下のようなものがある：

- システムの初期化： `init`
- OSの挙動変更： `sysctl`，`nice`，`sync`
- ファイル操作： `touch`，`mkdir`
- テキスト処理： `grep`，`sort`，`uniq`
- 性能測定： `sar`，`iostat`
- コンパイラ： `gcc`
- インタプリタ： `python`，`ruby`
- シェル： `bash`
- ウィンドウシステム： X


# 3章 プロセス管理

カーネルによるプロセス生成/削除の機能について触れる．実際のLinuxに於けるプロセス生成/削除には **仮想記憶** という概念が関わっており，これは5章で触れる．ここでは仮想記憶がない単純な場合を扱う．


## 2段階のプロセス生成

プロセス生成には2つの異なる目的がある：

- 同じプログラムによる処理を複数走らせる
- 全く別のプログラムを走らせる

これらそれぞれの目的に対して  `fork()` と `execve()` という2つのC言語の関数があり，これらは内部的に `clone()` と `execve()` というシステムコールを発行する．


## `fork()` 関数

`fork()` の呼び出しは次のような流れでプロセスを生成する：

1. 子プロセス用のメモリ領域を確保し，親プロセスのメモリの内容をそこにコピーする．
2. 親プロセスと子プロセスとで違うコードを実行するように分岐する．これは `fork()` の戻り値が親と子で異なるものになることを利用する．
