
# 2章 ユーザモードで実現する機能

ユーザモードからカーネルモードの処理が必要なときは **システムコール** を介して呼ばれる．

## システムコール

システムコールは以下のような操作を担う：

- プロセス生成/削除
- メモリ確保/解放
- プロセス間通信
- ネットワーク処理
- ファイルシステム操作
- ファイル操作（デバイスへのアクセス）


### CPUのモード遷移

システムコールはCPUの特殊な命令を実行することで発行する．システムコールが発行されると割り込みが発生し，ユーザモードからカーネルモードに遷移して該当する処理が走り，その処理が終わると再びユーザモードに戻る．カーネルモードの開始時にはプロセスからの要求が正当であるかがチェックされ，不正なら失敗させる．（もしプロセス自身がモードを切り替える手段を持っているなら権利の設計としておかしいため，このような仕組みになっている）．


### システムコール呼び出しの様子

`strace -o 〈Log〉 〈Command〉`  で，通常のコマンド `〈Command〉` による処理に対して発行されたシステムコールのログが `〈ログファイル〉` に出力される．例えばHello Worldプログラムでは `write()` が発行されている様子がわかる（ほかにも前後にプロセスの開始処理と終了処理に伴うシステムコールがたくさん発行される）．


### 実験

**`sar` コマンド** で各CPUコアがユーザモードとカーネルモードのどちらで実行しているかの割合を見ることができる．


### システムコールの所要時間

`strace` の `-T` オプションを使うと各システムコールの処理に何マイクロ秒かかっているのかを出力できる．


## システムコールのラッパー関数

システムコールは（CPUの実装に依存することから）アーキテクチャ依存のアセンブリコードを使って呼び出す必要があり，C言語などの或る程度高級な言語からはこれをラップして “FFI的に” 呼び出せるようにしてある（OSがライブラリを提供している）．


## 標準Cライブラリ

C言語にはISOが定めた標準ライブラリがあり，Linuxもこれに準拠してライブラリを提供している．通常はGNUの `glibc` で，これがシステムコールのラッパーを含む．

プログラムがどんなライブラリをリンクしているかは **`ldd` コマンド** で確かめることができるので見てみるとよい．


## OSが提供するプログラム

OSはライブラリだけでなくプログラムも提供しており，（よく知っているように）以下のようなものがある：

- システムの初期化： `init`
- OSの挙動変更： `sysctl`，`nice`，`sync`
- ファイル操作： `touch`，`mkdir`
- テキスト処理： `grep`，`sort`，`uniq`
- 性能測定： `sar`，`iostat`
- コンパイラ： `gcc`
- インタプリタ： `python`，`ruby`
- シェル： `bash`
- ウィンドウシステム： X


# 3章 プロセス管理

カーネルによるプロセス生成/削除の機能について触れる．実際のLinuxに於けるプロセス生成/削除には **仮想記憶** という概念が関わっており，これは5章で触れる．ここでは仮想記憶がない単純な場合を扱う．


## 2段階のプロセス生成

プロセス生成には2つの異なる目的がある：

- 同じプログラムによる処理を複数走らせる
- 全く別のプログラムを走らせる

これらそれぞれの目的に対して  **`fork()`** と **`execve()`** という2つのC言語の関数があり，これらは内部的に `clone()` と `execve()` というシステムコールを発行する．


## `fork()` 関数

`fork()` の呼び出しは次のような流れでプロセスを生成する：

1. 子プロセス用のメモリ領域を確保し，親プロセスのメモリの内容をそこにコピーする．
2. 親プロセスと子プロセスとで違うコードを実行するように分岐する．これは `fork()` の戻り値が親と子で異なるものになることを利用する．


## `execve()` 関数

全く別のプログラムによるプロセスを生成する場合は以下の流れによる：

1. 実行ファイルを読み出してプロセスのメモリマップに必要な情報を得る．
2. 現在のプロセスのメモリを新しいプロセスのデータで上書きする．
3. 新しいプロセスでプログラムを最初の命令から実行する．

つまり，プロセスが増えるのではなく既存のプロセスが書き換わる．

Linuxの実行ファイルは **ELF** (**Executable Linkable Format**) という形式で記録されている．**`readelf` コマンド** を使うと実際の実行ファイルにどんなメタデータ，コード領域，データ領域が含まれているのかを見ることができる．

実際にプログラムが走っている際のメモリマップは，`cat /proc/〈PID〉/maps` で見ることができる．

全く新しい別プロセスを生成する場合は，まず `fork()` で子プロセスを生成し，その後に `execve()` を呼んでプログラムを変更するという手順をとる．例えば `bash` が `echo` を呼び出すときも，まず `bash` の子プロセスをつくり，それを `echo` にプログラムに書き換えて実行を開始する．


## 終了処理

プログラムの終了は `_exit()` 関数が使われる．これは内部的に `exit_group()` システムコールを発行する．Linuxはこれによりそのプロセスに割り当てられていたメモリを回収する．

ユーザランドでは通常はこの関数を直接呼び出さず，そのラッパ的関数である `exit()` を呼び出す．C言語製の実行ファイルは `main()` が戻り値を返した時も同様の処理が走るようにコンパイルされている．


# 4章 プロセススケジューラ

この章では複数のプロセスが “同時に走っている” ようにするために必要な仕組みについて実験する．

マルチコアCPUでは1つのコアが1つの **論理CPU** という単位でLinuxに認識される．なお，**ハイパースレッド機能** が有効な場合は各コア内のハイパースレッドが論理CPUとして認識される（6章参照）．


## 実験プログラムの仕様

ひたすらCPU時間を使う処理をして有限時間で終わるプロセスを1個以上同時に動かして，全てが完了するまで以下を観察する：

- 或る時点で各論理CPU上でどのプロセスが動作しているか
- それぞれの進捗はどれだけか

実験プログラムは以下の引数をとる：

- `n`： 同時に動かすプロセス数
- `total`： プログラムを動作させる合計時間
- `resol`： 統計情報の採取間隔

（実際の実装が掲載されている）


## 実験

`n={1,2,4}`，`total=100`，`resol=1` で実験して比較する．結果は元の本参照（1論理CPU内では普通に並行していることが確かめられる）．


## 考察

以下のことがわかる：

- 1つの論理CPU上で各瞬間に動作できるプロセスは1つだけ
- 論理CPU上ではプロセスを順番にラウンドロビン方式で実行している
- 各プロセスのタイムラプスは大体等しい
- 全プロセス終了までの所要時間はプロセス数に比例して増加する


## コンテキストスイッチ

論理CPU上で動作するプロセスが切り替わるときにはコンテキストスイッチという処理が行なわれる．


## プロセスの状態

プロセスには次のような状態がある（網羅しているわけではないが，以下が典型的）：

- **実行状態**： 現在論理CPUを使っている
- **実行待ち状態**： CPU時間が割り当てられるのを待機している
- **スリープ状態**： 何らかのイベントが発生するのを待機しており，イベント発生まではCPU時間を使わない
  * イベントとはキーボードなどによるユーザ入力とか，タイマーの発火とか，ディスクへの書き込み完了とか，ネットワークを介した送受信の完了といったもの．
- **ゾンビ状態**： プロセスとして終了した後であり，親プロセスが終了状態を受け取るのを待っている

実際に `ps ax | wc -l` を叩くとわかるが，何も起動していないように見えても実際には300件くらいのプロセスが動作している．上記の実験で他のプロセスの影響がなかったのは，それらがスリープ状態だったため．各プロセスがどの状態なのかは `ps ax` の出力結果の3列目を見るとわかる．

- `R`： 実行状態/実行待ち状態．
- `S` または `D`； スリープ状態．後者はシグナルによって実行状態に戻ったりはしないもので，ディスクへのアクセスなどが該当する．
- `Z`： ゾンビ状態．


## 状態遷移

プロセスは或る意味では “有限状態機械” で，以下のように状態遷移する：

```
開始
 |      CPU実行権を得る
 |       +--------+
 |       |        |
 V       |        V       終了処理を呼ぶ             親プロセスが終了
[実行可能状態]     [実行状態]------------->[ゾンビ状態]-------------->[終了]
 ^       ^        |    |
 |       |        |    |
 |       +--------+    |
 |      CPU実行権を失う  |
 |                     |
 +----[スリープ状態]-----+
イベント発生      イベント待ち
```


## アイドル状態

論理CPU上でどのプロセスも実行状態でない期間は，**アイドルプロセス** という何もしない特殊なプロセスが動作する．このプロセスはCPUの特殊な命令を用いて論理CPUを休止状態（**アイドル状態**）にし，休止状態のCPUは1つ以上のプロセスが実行可能状態になるまで待機する．なんのプログラムも動かしていないと消費電力が抑えられるのはこのため．

論理CPUが単位時間あたりでどの程度アイドル状態にあったかは `sar -P ALL 1` などで確認できる．実際，`while (1)` などで無限ループするプログラムを動かすとアイドル状態が0になることが実験的に確かめられる．


## スループットとレイテンシ

- **スループット**： 単位時間あたりの総仕事量（高いほど良い）
- **レイテンシ**： 各処理の開始から終了までの経過時間（短いほど良い）

演繹的には明らかに以下が言える：

- 全ての論理CPUがアイドル状態にならない状況下では，プロセスを増やしてもスループットは変わらない．
- プロセスを増やすほどレイテンシは悪化する．


## 実際のシステム

スループットとレイテンシはトレードオフになりがち．プログラムを書くときは，望ましい目標を定義し，`sar` を使って測定することでチューニングしたりする．


## 論理CPUが複数の場合のスケジューリング

論理CPUが複数ある場合は，**ロードバランサ** または **グローバルスケジューラ** と呼ばれる機能が動作し，各論理CPUにプロセスを公平に分配する役割を担う．


## 実験方法

論理CPUが複数ある場合の動作は，**`taskset` コマンド** で実際にCPUを指定して行える．これは内部で `sched_setaffinity()` というプロセスを特定の論理CPUに制限するシステムコールを呼んでいる．


## 実験結果

2つのプロセスを2つの論理CPUで走らせると，それぞれ真に同時に走っていることが確かめられる．また，4つのプロセスを2つの論理CPUで走らせると，各論理CPUには2つずつプロセスが割り振られ，独立に両CPU上でそれぞれ2つのプロセスが切り替わりながら走る様子もわかる．


## 優先度の変更

OSは原則としてプロセスに対し平等にスケジューリングを行なうが，特定のプロセスの実行の優先度を高く設定することもでき，そのために **`nice()`** というシステムコールが用意されている．これはプロセスに−19から20までの整数で実行優先度を与えるもので，デフォルトは0であり，大きいほど優先度が高い．優先度が高いプロセスほどCPU時間を多く割り振るようにスケジュールされる．優先度を下げるのは権限に制約がないが，優先度を上げるにはroot権限を要する．


# 5章 メモリ管理

Linuxはシステムに搭載されている全メモリをカーネルの **メモリ管理システム** と呼ばれる機能により管理する．


## メモリに関する統計情報

**`free` コマンド** により，システムが搭載しているメモリの量と現在使用中のメモリの量を見ることができる．出力は以下のような項目をもつ：

- `total` フィールド： システムが搭載している全メモリ量．
- `free` フィールド： 見かけ上の空きメモリ量
- `buff/cache` フィールド： **バッファキャッシュ** と **ページキャッシュ**（6章参照）が使っているメモリ量．これらは空きメモリが減ってきたらカーネルによって解放される．
- `available` フィールド： 実質的な空きメモリ量．`free` の値に解放可能なカーネル内メモリ領域の量を足したもの．


## Out Of Memory

メモリ使用量が増えてくると，メモリ管理システムはまずカーネル内の解放可能なメモリ領域を解放する．その後もメモリ使用量が増えてどうしてもメモリが確保できなくなった場合，OSは **Out Of Memory**（**OOM**）という状態になる．この状態に至ると，メモリ管理システムは適切にプロセスを選んで強制終了することでメモリを解放するという最終手段を取る．

業務用のサーバなどでは，OOMが生じたときにどのプロセスが強制終了させられたかわからない状態で稼働し続けるのは困るので，OOMが発生するとシステムを強制終了するという設定にすることがある（`sysctl` の `vm.panic_on_oom` パラメータを `1` に設定すると可能）．


## 単純なメモリ割り当て

Linuxでのメモリ割り当ての仕組みには仮想記憶というものが欠かせないが，ここでは仮想記憶を加味しない単純な仕組みを説明し，その問題点を挙げる（この問題点を解決するのがまさに仮想記憶）．

カーネルがプロセスにメモリを割り当てるのは以下の2つのタイミングがある：

- プロセス生成時（これは3章で見た）
- プロセス生成後，追加で動的に確保するとき（これがこの章の内容）

プロセスは，追加でメモリが必要になったらメモリ獲得用のシステムコールを発行することでカーネルに確保を要請する．カーネルはそれをうけて必要な量のメモリを割り当てて，その先頭アドレスを返す．

この単純な方法には以下のような問題点がある：

- 断片化が進むと新たな確保に支障が出る
- 別用途のメモリにアクセスできてしまう
  * メモリのアドレスが丸裸なので，プロセスが自分用でないメモリにアクセスできてしまうなど抽象化に漏れがある．特にカーネルのメモリ領域にアクセスできるとまずい．
- マルチプロセスの扱いが困難
  * 各プログラムに於いてコードが何番地，データが何番地と決まった位置にあることを想定するように書かれていると，同じプログラムでもうひとつプロセスを立ち上げたりすると不整合が起きる．2種類以上のプログラムを共存させる場合も，使用するメモリの番地が重複するとやはり不整合が起きる．


## 仮想記憶

前節の問題点を解消するため，現代的なCPUには **仮想記憶** という仕組みが備わっており，これによりプロセスから見える **仮想アドレス** を実際の物理的なメモリの番地である **物理アドレス** にマップすることで抽象化をはかっている．プロセスから直接物理アドレスにアクセスする方法は存在しないようになっている．

このアドレス変換は実際にはカーネルが使うメモリ内に保持されている **ページテーブル** という表を引くことで行なう（CPUがカーネルを介さずに直接見る）．仮想記憶ではメモリはページ単位で管理されており，アドレス変換もページ単位で行なわれる．ページテーブル中の1つのページに対応するデータを **ページテーブルエントリ** と呼ぶ．ページテーブルの大きさはアーキテクチャごとに異なり，例えばx86\_64では4KB．

ページテーブルはページ単位で仮想アドレスごとにそれに紐づく物理アドレスがどこか，或いは存在しないかを保持しており，存在しないものを引いた場合は **ページフォルト** という割り込みが発生する．これに対してはページフォルトハンドラという処理が動き，この処理の中でプロセスによるメモリアクセスが不正だったことを検知する．その後 **SIGSEGV** というシグナルによりプロセスにその旨を通知し，通常その通知を受けたプロセスは強制終了させられる．

仮想記憶により以下の恩恵が得られる：

- 仮想アドレスでは連続していても物理アドレスではバラバラなように割り振ることができるので，断片化の問題が生じない．
- 仮想アドレス空間はプロセスごとに独立に確保されるので，別のプロセスやカーネルのメモリにアクセスすることはできず抽象化に漏れがない．
  * カーネルのメモリは，実装上の都合により実は全てのプロセスの仮想アドレス空間にマップされている．ただし，これはカーネルモードで動作しているときにしか読めないようになっているため，ユーザモードからカーネルのメモリを見たり変更したりすることはできない．
- マルチプロセスの取り扱いも同様の理由により困難が生じない．


## 仮想記憶の応用
