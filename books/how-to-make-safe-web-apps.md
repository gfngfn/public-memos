
# 3

## 3.1 HTTPとセッション管理

* `Referer` ヘッダ
  - リンク元のURLを示す
  - フォームの送信や `a` 要素でのリンク移動のほか `img` 要素の `src` による画像への参照リクエストでもつく
  - URLにセッションIDなどの秘匿情報を含めてしまっている場合，この `Referer` ヘッダを経由して漏洩し，なりすましに使われる．
* **hiddenパラメータ**
  - `<input type="hidden" name="〈Name〉" value="〈Value〉">` でフォーム中に追加できる，GUI上はユーザに見えないパラメータ
  - ユーザが書き換えることはできるが，漏洩や第三者の書き換えに対しては堅牢．
  - 用途上クッキーやセッション変数と比較されることがある．
    * これらはセッションIDの固定化攻撃に対して脆弱．
    * ユーザに書き換えられては困る認証情報はセッション変数に保存すべし（→詳細は5.1節，5.3節）
    * セッション変数は **クッキーモンスターバグ** による漏洩に対する効果的対策がない状況がある（→詳細は4.6.4項）
* クッキー
  - サーバ側からレスポンスの `Set-Cookie` ヘッダで値を送ることによりクライアント側に値を覚えさせる機構．
  - ブラウザが一旦ドメインごとに対応するクッキー値を覚え，リクエストを投げる際にはその送信先のドメインに対応するクッキー値を `Cookie` ヘッダを入れて送る．
  - 長さに制限があり，またユーザが書き換えることもできるので，生のアプリケーションデータそのものを入れて使うことは普通しない．普通は “整理番号” を格納する．この整理番号を **セッションID** と呼ぶ．
  - セッションIDを管理する機構は脆弱性の温床なので，なるべく自作せず実績のある既存実装に頼ることが重要．
* セッションIDに求められる要件
  - 第三者がセッションIDを推測できないこと
    * 推測できると悪人がその推測可能なセッションIDをもつユーザになりすまして認証を通ってしまうため（66頁のなりすましの比喩的事例参照）
  - 第三者からセッションIDを強制されないこと
    * 強制可能な仕組みがあると **セッションIDの固定化攻撃** という手法でなりすましができてしまう（67-68頁の比喩的事例参照）
    * 認証のたびに新しいセッションIDに変更することで防げる．
* セッションIDが漏洩する原因
  - クッキー発行の際の **属性** の指定の不備
    * （これについてはすぐ下で後述）
  - ネットワークに仕掛けられた盗聴機構から漏れる（→8.3節）
    * これはTLSで暗号化して防げるが，それでも属性の指定には注意が必要
  - クロスサイトスクリプティングなど，アプリケーションの脆弱性により漏れる（→4章）
  - ブラウザの脆弱性により漏れる
  - （上で挙げた通り）URLに含めてしまっており `Referer` ヘッダから漏洩する（→4.6.3項）
* クッキーの属性
  - 以下の属性がセキュリティ上重要：
    * `Domain`
      - ブラウザがクッキー値を送信するドメイン．
      - デフォルトではレスポンスを返したサーバのドメインのみがクッキー値の送信対象になり，これが最も安全だが，複数のサーバに送信されるクッキー値を生成したい場合もあり，その際にはこの属性を使う．
      - 使用例： `Set-Cookie: x=123; Domain=example.jp`
      - `a.example.jp` が `Domain=example.jp` を指定して `b.example.jp` にもクッキー値が送られるようにすることはできるが，`Domain=foo.com` のように自身の接尾辞ではない “本当に関係ないドメイン” を指定することはできない．
        * そういった指定はブラウザ側が無視する．
        * 指定できてしまうとセッションIDの固定化攻撃の脆弱性となるため．
      - しかし `a.example.jp` と `b.example.jp` のようなドメインでも互いに運営者が違うことはあり，`Domain=example.jp` と設定すると前者のクッキーは後者に漏洩してしまうことになる．そのため，**基本的には `Domain` 属性は設定するものではない**．
        * 古いブラウザだと `Domain=co.jp` というドメインのクッキーが作れてしまう問題があり，例えば `yahoo.co.jp` から `amazon.co.jp` に簡単にセッションIDが漏れ得た．これは **クッキーモンスターバグ** (*Cookie Monster Bug*) と呼ばれる．
        * 地域型JPドメインと都道府県型JPドメインには案外最近のバージョンのブラウザまでクッキーモンスターバグがあった．これらのドメインを使う場合は固定化攻撃の対策に特に慎重を期する．
    * `Secure`
      - HTTPSの場合のみクッキーを送信するという指定．
      - →4.8.2項
    * `HttpOnly`
      - JavaScriptからこの属性にアクセスできるか否かの指定．
      - 固定化攻撃では，典型的には後述される **クロスサイトスクリプティング攻撃** によりJavaScriptを悪用してクッキーを盗み出すが，この属性をつけておくとその典型例に対して効果がある．
        * ただし全てのクロスサイトスクリプティング攻撃をこれで防げるわけではない．


## 3.2 受動的攻撃と同一オリジンポリシー

* 攻撃の種別
  - **能動的攻撃**： 攻撃者が直接攻撃対象のサーバに対してアクセスし改竄や漏洩などを試みること．
    * SQLインジェクションなど
  - **受動的攻撃**： Webサイト利用者に対して罠を仕掛けることにより，罠を閲覧したユーザを通してアプリケーションに攻撃を仕掛けようと試みること．
* 受動的攻撃の種別
  - 単純なもの
    * 罠サイトを開設し，ブラウザやプラグインなどの脆弱性を突くようなレスポンスを返すことで攻撃する．
  - 正規サイトの悪用
    * 正規サイトに何らかの不正操作を行ない（この段階だけ見ると能動的攻撃でもある），正規サイトにアクセスした閲覧者に攻撃の仕掛けられたレスポンスを返す．
    * 攻撃者から見れば，罠サイトに誘導する手間が要らない，利用者が多いと攻撃対象が拡大しやすい，などの利点がある．
    * よくある手法：
      - FTPのパスワードを不正入手しコンテンツを書き換える（→ 8.1節）
      - Webサーバの脆弱性を突いてコンテンツを書き換える（→ 8.1節）
      - SQLインジェクション（→ 4.4節）
      - SNSなどユーザが投稿できる機能のクロスサイトスクリプティング脆弱性につけこむ（→ 4.3節）
  - サイトをまたがるもの
    * 罠サイトを開設し，正規サイトへの攻撃となるリクエストを含むレスポンスを返すことで攻撃する．
    * 単に攻撃用のHTMLのURLが掲示板に貼られるなどの単純なものも多い．
    * よくある手法：
      - **クロスサイトリクエストフォージェリ** (CSRF)（→ 4.5節）
      - クロスサイトスクリプティング (XSS)（→ 4.3節，4.5節）
      - **HTTPヘッダインジェクション**（→ 4.7節）
* 受動的攻撃を防ぐ方法
  - ブラウザとWebサイトそれぞれが脆弱性を含まないようにする必要がある．
  - ブラウザによる対策： JavaScriptのサンドボクシング
    * ローカルファイルへのアクセスの禁止
    * **同一生成元ポリシー** (*same origin policy*)
      - 或るサイトが生成してクライアント側に送ったJavaScriptからは，別のサイトが生成してクライアント側に送ったDOMなどへの読み取りアクセスを禁止するセキュリティ上の制限．
      - これがないと，例えば悪意のあるサイトが `iframe` 要素で別サイトのページを読み込むことでそのページが取り扱うパスワードなどの内容をいくらでも取り出せてしまう．
      - 同一生成元であるとは以下の全てが一致している場合：
        * URLのホスト（つまりFQDN）
        * スキーム（プロトコル）
          - したがって同一のFQDNからでも例えばHTTPとHTTPSとでは異なる生成元とみなす．
        * ポート番号
      - Ajaxの `XMLHttpRequest` でアクセスできるURLにも同一生成元ポリシーが課されるが，意図的に同一生成元でないサイト間で跨ってやり取りしたい場合は相手側のサイトが許可すれば同一生成元でなくても通信できる **CORS** という規格がある（→ 3.3節）．
      - “`iframe` 要素の内側にJavaScriptを送って実行させる攻撃” （**クロスサイトスクリプティング**）ができるようになっているとこれは同一生成元ポリシーを以てしても防げない．
        * しかし実際にはアクセス解析用のソースやバナー広告，ブログパーツなど，第三者の提供するJavaScriptを許可せざるを得ない場合もある．これはサイト運営者または閲覧者がJavaScript提供元を信頼することで許可することになる．提供元が意図的に個人情報を収集していたり，提供元が意図しない動作が提供されたJavaScriptの脆弱性によって攻撃で差し替えられて発生したりするセキュリティ上の問題が頻繁に生じているので，慎重な判断を要する．このほか，ブラウザのアドオンにも同様の慎重さが必要（こちらはサイトが提供する通常のJavaScriptよりも強い権限で動作するのでさらに慎重を期する）．
      - `iframe` 以外でも `img`，`script`，`form` 要素の `action` 属性でクロスドメインが関わる．
        * `img` は特に制約なくクロスドメインでも指定可能．
        * `form` の送信もaction先がクロスドメインであっても操作可能．これを悪用するのがクロスサイトリクエストフォージェリ (CSRF)（→ 4.5節）．
        * `script` に関しては，（最近は全然名前を聞かないが）**JSONP** の取り扱いにリスクがある（→ 4.16.7項）．
        * CSSも特に制約なくクロスドメインでも指定可能．
          - ただし，かつてIEにはCSSでないデータがCSSとして読み出す際に部分的に読み出せてしまう脆弱性があり，**CSSXSS** と呼ばれていた．

## 3.3 CORS

* 同一生成元でないサイト間を跨ってデータをやり取りしたい場合はどうしてもあり，この要請に応える仕様として **CORS** (cross-origin resource sharing) が策定された．
* CORSに頼らなくとも，次を全て満たす **シンプルなリクエスト** の場合は提供側の許可なくできるようになっている：
  - メソッドはGET，HEAD，POSTのいずれか
  - `XMLHttpRequest` オブジェクトに対して `setRequestHeader` で設定されたHTMLヘッダが以下の範囲のみ：
    * `Accept`
    * `Accept-Language`
    * `Content-Language`
    * `Content-Type`
  - `Content-Type` ヘッダの値が以下のいずれか：
    * `text/plain`
    * `application/x-www-form-urlencoded`
    * `multipart/form-data`
* 以下でも述べるが，提供側が許可するドメインをレスポンスの `Access-Control-Allow-Origin` に与えることでブラウザに「このドメインに由来するJavaScriptコードからは私のレスポンスの内容を読み取っていいですよ」ということを伝えられるようになっている．
* シンプルなリクエストではないリクエストをクロスドメインで送信する場合，ブラウザはまず **プリフライトリクエスト** と呼ばれるHTTPリクエストを送信する．これには主に以下のようなヘッダを含める：
  - `Access-Control-Request-Method`
    * この後送る本番のリクエストメソッドが何であるかを伝え，メソッドに対する許可を得ようとする．
    * 例： `Access-Control-Request-Method: POST, GET, OPTIONS`
  - `Access-Control-Request-Headers`
    * 本番のリクエストメソッドに含めるヘッダを伝え，ヘッダに対する許可を得ようとする．
    * 例： `Access-Control-Request-Headers: content-type`
  - `Origin`
    * オリジンを伝え，許可を得ようとする．
    * 例： `Origin: http://example.jp`
* 提供側はプリフライトリクエストを受け取ったら403 Forbiddenを返して拒否するか，或いは以下のようなレスポンスヘッダを返して許可を出す：
  - `Access-Control-Allow-Origin`
  - `Access-Control-Allow-Methods`
  - `Access-Control-Allow-Headers`
* クッキーを受け取って使いたい場合は，`XMLHttpRequest` の `withCredentials` を `true` にしてリクエストを送る．
  - 提供側はそのリクエストに対して `Access-Control-Allow-Credentials: true` をヘッダにしてレスポンスを返す．するとクライアント側のブラウザは「提供元が許可した」と判断して `Set-Cookie` の内容を保持し，次回のリクエストにそのクッキーを含めるようになる．


# 4

## 4.1 Webアプリケーションの昨日と脆弱性の対応

## 4.2 入力処理とセキュリティ

* 入力を受けつける箇所で検証する項目：
  - エンコーディングの妥当性
  - エンコーディングの変換（必要であれば）
  - 入力値の文字列形式の妥当性
* 入力処理での検証の意義：
  - 内部エラーの防止
  - （内部エラーにはならないものの）データに不整合が生じる状況の防止
  - 入力値の誤りをクライアントやユーザに適切にフィードバックすることによるユーザビリティの向上
* **入力処理での検証の主目的はセキュリティのためではない**．
  - 入力値検証はアプリケーションの仕様に基づくものとし，脆弱性対策とは分離して定式化するのが良い．
  - “たまたま” 保険的に役立つことはある：
    * 例： SQLインジェクションの対策をしていなかったパラメータがあったが，英数字のみからなる文字列しか受けつけないバリデーションを入力処理に含めていたので実害に至らないようになっていた．
* **バイナリセーフ**： どんなバイト列が入力に来ても扱えること．特に `0x00`（ヌルバイト）が現れても処理できること．
  - ヌルバイトが現れるとそこを無条件に文字列終端と看なす仕様や実装の穴を突く攻撃手法が知られており，**ヌルバイト攻撃** と呼ばれる．
* 具体的な入力値の検証：
  - 制御文字のチェック
    * 注意： ここでは `0x20` は制御文字に含んでいない．
    * 例： 1行のテキストボックスなど改行を含んではいけない文字列なので，全ての制御文字を拒否する
  - 文字数のチェック
    * **全てのパラメータについて最大文字数を仕様として規定すべし**．
  - 数値の最大値と最小値のチェック
    * 数値の項目については取りうる値の最大値と最小値を仕様として規定すべし．

## 4.3 表示処理に伴う問題

### 4.3.1 XSS（基本編）

* XSSの被害例：
  - 攻撃者の用意したスクリプトの実行によりクッキー値を盗まれ，なりすましに使われる
  - 攻撃者の用意したスクリプトの実行により偽物の入力フォームが表示され，フィッシングにより個人情報を盗まれる
* クッキー値の盗み出し：
  - `"<p>「%s」の検索結果：</p>"` のような表示を行なう箇所で，ユーザの入力した検索文字列を表示する `%s` （これは `?search=…` というクエリパラメータ由来とする）に対してXSS対策が施されていない場合，`"<script>alert(document.cookie)</script>"` などと検索するとクッキーが表示できる．これは攻撃者本人のクッキーが表示されるだけだが，同様の方法論が罠サイトを用意することで別の利用者のクッキーの盗み出しに使える．罠サイトに `iframe` 要素を設けて，その `src` 属性にXSSを起こすクエリパラメータを追加した攻撃対象のURLを入れておく（特に上記のJavaScript断片を `alert` ではなくメールで送信するなどの函数に置換したものにしておく）と利用者のクッキーが盗める．
* ログイン機能がなく，かつJavaScriptを使っていない場合でも，formにXSSの脆弱性が潜むことがある．
  - formの文字列値に脆弱性対策が為されていない場合，`input` 要素の `value` 属性に `"\"></form>…"` という形の文字列値を与えて本来のフォームを終了させ，そこから `…` にCSSの絶対座標指定やz-indexを利用して罠のフォームを上書きする位置に置くなどの記述をして攻撃ができる．
  - コード例を見た方が早いので，126ページ参照．
  - したがって，利用者がJavaScriptを無効にしていてもXSSの被害にあう可能性は普通にある．
* 反射型XSSと持続型XSS
  - 攻撃用のスクリプトが攻撃対象とは別のサイトに置かれるXSSを **反射型XSS**，攻撃対象のDB等に保存されるようなXSSを **持続型XSS** と呼ぶ．
  - 持続型XSSの攻撃対象は，は典型的にはWebメールやSNS．利用者が罠サイトを避けるだけでは被害を防げない．
  - これらとは別に **DOM-based XSS** という概念もある（→ 4.17節）．
* 脆弱性の要因
  - 基本的には（`<` などの）“HTML上意味のある” 文字を（`&lt;` などへと）エスケープしていないことで生じる．
  - ただし，構文上の場所に応じてエスケープすべき方法は変わるので注意．
    * HTMLのタグに囲まれている部分のテキスト中と属性値の二重引用符で囲まれた文字列中とでは適切なエスケープ方法が違う．
    * 前者の場合は最低限 `<` と `&` とを文字参照へとエスケープしていればよい．
    * 後者の場合はそれに加えて `"` も最低限のエスケープ対象．
    * 属性値を二重引用符で囲んでいない場合は空白文字が値の終了と看なされるのでこれもXSSの抜け穴になる．恒に二重引用符で囲うべし．
* 保険的対策
  - ブラウザの中にはXSSの脆弱性と思しき入力を自前で検出して無害な出力に変換する機能（**XSSフィルタ** と呼ばれる）を持っているものもある．
  - XSSフィルタはデフォルトで有効だが，ユーザが無効に設定することもある．しかし `X-XSS-Protection: 1; mode=block` というヘッダをレスポンスに入れるとユーザの設定にかかわらずXSSフィルタを有効にできる（**恒にこれを追加することを推奨**）．
  - 4.2節で前述の通り，入力値検証が “たまたま” XSS対策になることがある．
  - クッキーの属性に `HttpOnly` をつけ，そもそもJavaScriptなどから読み取れないようにブラウザに指示する．
* 詳細は省かれているが，かつてはブラウザの脆弱性によりTRACEメソッドのJavaScriptによる送信がクッキーやBasic認証のIDとパスワードを盗み出せる **クロスサイトトレーシング**（**XST**）という攻撃手法があった．
  - 2006年頃には全主要ブラウザで対策が終わり，現在ではほぼリスクはないと言えるが，TRACEメソッドを許可していると脆弱性診断ツールが警告してくることはあるし，また例えばnginxのデフォルトの設定ではTRACEは許可されていない．

### 4.3.2 XSS（発展編）

* `href` 属性や `src` 属性では，URLとして `javascript:〈JavaScriptの式〉` という形式（**JavaScriptスキーム**）によってJavaScriptを起動できる．
  - これは二重引用符で囲われていても文字列がソースコードとして読み出されるので，`src="javascript:alert(document.cookie)"` などとなるように攻撃されたりしてXSSの要因となる（JavaScriptスキームとかいう厄介な仕様を用意してくれたもんだなあ）．
  - 対策：
    * 単に `http:` か `https:` か `/`（相対URL）で始まるもののみを許すようにチェックする．
    * さらに，1点目だけでは罠サイトを仕込まれるリスクがあるので，ドメイン名までチェックし，外部ドメインである場合はエラーにするか外部ドメインであることを注意喚起する（→ 詳細は4.7.1項）．
      - SNSなどで外部へのリンクを踏んだ際にクッションページが出るのはおそらくこれの対策．
* `body` の `onload` 属性．ここもJavaScriptコードを文字列で与えることができるので，XSSでコードが差し込まれる脆弱性となる．
  - そもそも挿入される値が “コードとして自由度が高い” 記述をしてはいけないが，`<body onload="init('%s')">` で `%s` をURLのクエリパラメータ `name` の値で埋めさせたい場合などがある．これは文字列リテラル中への埋め込みなので “自由度が低く” 比較的マシだが，これでも文字列リテラル宙の文字を適切にエスケープしないと `%s` の内容で文字列終端を勝手につくられてしまうXSSの脆弱性となる．例えば `');alert(document.cookie)//` を `name` に与えると `<body onload="init('');alert(document.cookie)//')">` という具合に攻撃できる．
  - 対策： JavaScriptの文字列リテラル中として，最低限 `\`，`"`，`'`，改行のエスケープが必要．
* `<script>…</script>` の中身にサーバサイドでユーザからの入力を含める場合
  - これも基本的には1つ前の項目と同じで，そもそも “自由度を高く” してはいけない．
  - ただし，こちらは文字列リテラル中のみであっても引用符や改行をエスケープするだけでは事足りない．`</script>` が挿入されるとJavaScriptコードとしての文脈に関わらずHTMLのパース上そこがコードの終端と扱われてしまうため．したがって `</script><script>alert(document.cookie)//` のような内容を挿入されるとXSSが起こされてしまったりする．
  - 対策：
    * `</script` という文字列が出現しないようにする．
    * そもそも漏れが発生しやすいのでJavaScriptコードに動的生成される部分を含めることを避ける．
    * **カスタムデータ属性** という，`script` 要素の外側でパラメータを定義してJavaScript側から参照する方法を用いる．

### 4.3.3 エラーメッセージからの情報漏洩

* エラーメッセージからの情報漏洩には以下の2パターンがある：
  - エラーメッセージに攻撃者にとって有利な内部情報が含まれてしまっている
  - 意図的な攻撃の結果エラーメッセージに秘匿すべきデータが見えてしまう
    * SQLインジェクションで起こすなど（→ 詳細は4.4.1項）
* いずれにしても攻撃に有用な情報を与えないためにユーザに供するエラーメッセージは「アクセスが集中しています」などの簡素な報告のみにし，エラーの詳細は内部的なログに記録するにとどめる．
  - （→ 5.4節 ログ出力）


## 4.4 SQL呼び出しに伴う脆弱性

### 4.4.1 SQLインジェクション

* SQLの呼び出し方に不備がある場合の脆弱性．
* 例えば攻撃者に以下の影響を及ぼす能動的な攻撃を許してしまう：
  - DB内の全てのデータを盗み出す
  - DBの内容を書き換える
  - 認証を回避させ，IDとパスワードなしでログインする
  - DBサーバ上でファイルの閲覧・書き込みをしたりプログラムを実行したりする
* 例1：
  - 脆弱性のあるクエリ： `SELECT * FROM books WHERE author='$author' ORDER BY id`
    * 書籍検索結果を表示するページのサーバサイドの処理．
    * `$author` はクエリパラメータの `?author=…` から取るとする．
  - 正常系： `?author=ShakeSpeare`
  - 攻撃： `?author='+AND+EXTRACTVALUE(0,(SELECT+CONCAT('$',id,":",pwd)+FROM+users+LIMIT+0,1))+%23`
    * `SELECT CONCAT('$',id,":",pwd) FROM users LIMIT 0,1` というサブクエリが攻撃の中心．
    * これが埋め込まれたSQLクエリがサーバで実行されると `"$〈ユーザID〉:〈パスワード〉"` という文字列が1件だけ取り出され，それを `EXTRACTVALUE` 函数がパースしようとして以下のようなエラーが出る：
      - `Error : SQLSTATE[HY000]: General error: 1105 Unknown XPATH variable at: '$yamada:pass1'`
      - つまり `yamada` というIDのユーザのパスワードが `pass1` であることが漏れてしまっている．
      - 4.4.3項で扱ったように，これはエラー表示からデータが漏れる例でもある．
* 例2：
  - クエリは上と同じ
  - 攻撃： `?author='+UNION+SELECT+id,pwd,name,addr,NULL,NULL,NULL+FROM+users--+`
    * この `UNION SELECT` を用いた攻撃を実行されると大量のユーザ情報が漏れてしまう．
* 例3： 認証回避
  - クエリ： `SELECT * FROM users WHERE id = '$id' pwd = '$pwd'`
  - 攻撃： `$pwd` が `' OR 'a'='a` になるように攻撃
    * `WHERE` 句が恒真となるため認証に成功されてしまう．
* 例4： 改竄
  - クエリは例1と同じ
  - 攻撃： `?author='UPDATE books SET title%3D'<i>cracked!</i>+WHERE+id%3D'42'--+`
    * `%3D` は `=` のエンコーディング
    * IDが42番の書籍のタイトルが上書きされてしまう．
* 例5： DBサーバ上の任意ファイルの読み取り
  - クエリ： `?author=';LOAD+DATA+INFILE+'/etc/passwd'+INFO+TABLE+books+(title)--+`
  - `LOAD DATA INFILE '/etc/passwd' INFO TABLE books (title)` というSQL文が呼び出され，`/etc/passwd` の内容が `books` テーブルの `title` カラムに読み込まれる．
  - 続いて `?author='OR+author+is+NULL--+` のクエリで閲覧すると，`/etc/passwd` の各行が書籍のタイトルとして表示され，読み取りに成功してしまう．
* 脆弱性の要因
  - 基本的にはSQL文にクエリ由来の文字列が埋め込まれる際にエスケープができていないために起こる．
  - SQLの文字列リテラル中で引用符をエスケープする場合は `''` と重ねる．
    * 例： `'O''Reilly'`
    * `\'` などではないことに注意．
    * SQL文を読む側からすれば，先読みしないと文字列リテラルの終端がわからない仕組み．
* 対策
  - 根本的な解決には以下の2種類の方法がある：
    * 適切にエスケープしてSQL文の構造が確実に変更されないようにする
      - エスケープ処理を適切に実装するのは難しいので，これは非推奨．
    * **プレースホルダ** によりSQL文を組み立てる
      - 例： `SELECT * FROM books WHERE author = ? ORDER BY id`
      - 値が埋め込まれるべき箇所を `?`（フォーマットの `%s` のようなもの）にしておいて別の箇所でそれに対応する値を与える（＝**バインド** する）．
      - 以下の2者がある：
        * **静的プレースホルダ**： `?` つきの文を本当にDBクエリとして叩き，`?` に対応する内容もDBエンジンに別で送り，DBエンジン側でバインドを行なう．
          - こちらの方がより安全なので，できる限りこの方法にする．
        * **動的プレースホルダ**： アプリケーション側でライブラリなどを用いてバインドしてからDBエンジンにクエリを送る．
          - これはライブラリや処理系などに不具合があるとインジェクションの要因となるので注意．
* 保険的対策：
  - 複文の実行の禁止
    * SQLの機能として実現可能．
  - 詳細なエラーメッセージの抑止
  - 入力値のバリデーション（前述の通り）
  - DBの権限設定


## 4.5 「重要な処理」の際に混入する脆弱性

### 4.5.1 クロスサイト・リクエストフォージェリ (CSRF)

* クレジットカード決済，メール送信，パスワード変更などの，Webアプリケーション上で起こる “取り消しできない処理” を **「重要な処理」** と呼ぶことにする．
* 「重要な処理」を受けつける際にはそれが利用者の意図したリクエストであることを確認する必要があるが，この確認処理が抜けていると罠サイトの閲覧などをしただけでブラウザから勝手に意図しない「重要な処理」を実行させられてしまう場合がある．こうした脆弱性を **CSRF脆弱性** と呼び，これを悪用する攻撃を **CSRF攻撃** と呼ぶ．
  - CSRF脆弱性は（UIなどの備わったWebアプリケーションに限らず）Web APIでも混入しうる（→4.16.5項）．
* CSRF攻撃とXSS攻撃は攻撃に至るまでの経路は似ているが，実際に攻撃する対象が異なるので混同に注意．
  - CSRFは罠サイトから仕掛けのあるレスポンスを返し，そこから正規サイトに攻撃のリクエストを飛ばして正規サイトのサーバで不正操作（つまり利用者の意図しない動作）を起こす．
  - XSSは攻撃のリクエストを飛ばすまでは一緒だが，それに対するレスポンスにオウム返し的に仕掛けを含ませ，クライアント側のブラウザで仕掛けのスクリプトを走らせて攻撃を起こす．
  - CSRFは正規サイトのサーバのもつ機能の範囲で意図しない動作を起こさせる攻撃だが，XSSは任意のスクリプトをクライアント側で走らせる処理なので，一般論としてはXSSの方が攻撃の表現が広範なものとなり脅威として大きいといえる．
  - しかしCSRFは以下の点で注意を要する：
    * 設計段階から対策を盛り込まねばならない
    * 開発者による認知度が低いという人間的な理由で対策が進みにくい
* 罠サイトでは，実際には攻撃の様子をユーザから隠すために見えない `<iframe>` を使う．攻撃対象である正規サイトからのレスポンスが書かれた `<iframe>` の内側の内容を罠サイト側が読み取ることは同一生成元ポリシーにより不可能だが，例えばこの攻撃で罠サイト側がパスワードを変更するという「重要な処理」を行なう場合，罠サイト側は新しいパスワードを当然知っているので，正規サイトからのレスポンスを読むことなく不正ログインに使える情報を得られている．
* 「CSRF攻撃は，実際に『重要な処理』を行なう実行用ページの前に確認用ページを挟めば防げる」と思われていがちだが，そうではない．
  - 例： メールアドレスを変更するという「重要な処理」
    * 新しいメールアドレスをフォームのhiddenパラメータなどで受け渡ししている場合：
      - 新しいメールアドレスという漏れてはいけないデータがHTTPリクエストの入力として渡されていることには変わりないので，罠サイトから攻撃できる．
    * 新しいメールアドレスを確認用ページでセッション変数に保存し，実行用ページでセッション変数から取り出している場合：
      - 2段階を経れば依然として攻撃可能．2つ `<iframe>` を使い，1つ目で確認用ページへリクエストを飛ばし，2つ目で10秒後などタイミングを見計らって実行用ページへリクエストを飛ばす．
* ファイルのアップロードにもCSRF脆弱性が潜みうる．
  - ファイル名やファイルの中身をページ側から指定することはできないのでCSRF脆弱性はないと思いがちだが，クロスオリジンに対応した `XMLHttpRequest` によって攻撃できる．
  - 罠サイトは攻撃対象サイトにログインしているユーザからのアクセスがあると `withCredentials` に `true` を設定したリクエストオブジェクトを用いてクッキー値をヘッダに入れ，攻撃対象サイトにアップロードしたい任意のファイルを送れる．
  - ちなみにこのとき罠サイト側は（攻撃対象と同一生成元ではないため）CORSの仕様によりレスポンスを受け取れないが，CSRF攻撃はリクエストが攻撃対象のサーバに到達するだけで成立しレスポンスからデータを得る必要はないので攻撃として成立する．
* CSRF脆弱性の要因
  - そもそもWebのもつ以下のような性質に本質的に要因があるといえる：
    * `<form>` の `action` 属性にどんなドメインのURLを指定しても有効なこと
    * クッキー値として保管されたセッションIDが（どんなアクセスであっても）自動的に対象サイトへのリクエストに含められて送信されること
* 対策
  - まずはWebサービスの仕様を書き起こす段階でCSRF対策の必要な「重要な処理」をする遷移の箇所を洗い出し，要件定義・基本設計・開発の各段階で対応することが必要
  - その上で，正規利用者からのリクエストと罠サイトからのそれを区別するには以下の方法がある：
    * 秘密情報（＝トークン）の埋め込み
      - 「重要な処理」のリクエストの受けつけに際し，第三者が知り得ない秘密情報を要求するようにする．
      - 「重要な処理」の実行へ遷移する前の正規のページに，「重要な処理」のリクエストに際して送るトークンをhiddenパラメータとして埋め込んでおくなど．
      - トークンには第三者から推測されにくい値を用いる必要があり，擬似乱数などによって生成する．
      - アプリケーションフレームワークがこのようなトークンを生成する機能を提供していたりする．
    * パスワード再入力
    * リクエストヘッダ中の `Referer` のチェック
      - 自身である正規サイトからのアクセスの場合は `Referer` にその正規のURLが入っているはず．罠サイトならそのドメインが入っている．
      - 最も簡便な対策で済むのが利点．
      - 一方でドメインのチェックは漏れが生じやすい．
        - 罠サイトのドメインが正規サイトのドメインを接頭辞にもつ場合など．
      - 利用者が限定でき，かつ既存の脆弱性を潰す場合のみに限って利用するのが無難．
