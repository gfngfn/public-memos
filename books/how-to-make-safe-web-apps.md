
# 3

## 3.1 HTTPとセッション管理

* `Referer` ヘッダ
  - リンク元のURLを示す
  - フォームの送信や `a` 要素でのリンク移動のほか `img` 要素の `src` による画像への参照リクエストでもつく
  - URLにセッションIDなどの秘匿情報を含めてしまっている場合，この `Referer` ヘッダを経由して漏洩し，なりすましに使われる．
* **hiddenパラメータ**
  - `<input type="hidden" name="〈Name〉" value="〈Value〉">` でフォーム中に追加できる，GUI上はユーザに見えないパラメータ
  - ユーザが書き換えることはできるが，漏洩や第三者の書き換えに対しては堅牢．
  - 用途上クッキーやセッション変数と比較されることがある．
    * これらはセッションIDの固定化攻撃に対して脆弱．
    * ユーザに書き換えられては困る認証情報はセッション変数に保存すべし（→詳細は5.1節，5.3節）
    * セッション変数は **クッキーモンスターバグ** による漏洩に対する効果的対策がない状況がある（→詳細は4.6.4項）
* クッキー
  - サーバ側からレスポンスの `Set-Cookie` ヘッダで値を送ることによりクライアント側に値を覚えさせる機構．
  - ブラウザが一旦ドメインごとに対応するクッキー値を覚え，リクエストを投げる際にはその送信先のドメインに対応するクッキー値を `Cookie` ヘッダを入れて送る．
  - 長さに制限があり，またユーザが書き換えることもできるので，生のアプリケーションデータそのものを入れて使うことは普通しない．普通は “整理番号” を格納する．この整理番号を **セッションID** と呼ぶ．
  - セッションIDを管理する機構は脆弱性の温床なので，なるべく自作せず実績のある既存実装に頼ることが重要．
* セッションIDに求められる要件
  - 第三者がセッションIDを推測できないこと
    * 推測できると悪人がその推測可能なセッションIDをもつユーザになりすまして認証を通ってしまうため（66頁のなりすましの比喩的事例参照）
  - 第三者からセッションIDを強制されないこと
    * 強制可能な仕組みがあると **セッションIDの固定化攻撃** という手法でなりすましができてしまう（67-68頁の比喩的事例参照）
    * 認証のたびに新しいセッションIDに変更することで防げる．
* セッションIDが漏洩する原因
  - クッキー発行の際の **属性** の指定の不備
    * （これについてはすぐ下で後述）
  - ネットワークに仕掛けられた盗聴機構から漏れる（→8.3節）
    * これはTLSで暗号化して防げるが，それでも属性の指定には注意が必要
  - クロスサイトスクリプティングなど，アプリケーションの脆弱性により漏れる（→4章）
  - ブラウザの脆弱性により漏れる
  - （上で挙げた通り）URLに含めてしまっており `Referer` ヘッダから漏洩する（→4.6.3項）
* クッキーの属性
  - 以下の属性がセキュリティ上重要：
    * `Domain`
      - ブラウザがクッキー値を送信するドメイン．
      - デフォルトではレスポンスを返したサーバのドメインのみがクッキー値の送信対象になり，これが最も安全だが，複数のサーバに送信されるクッキー値を生成したい場合もあり，その際にはこの属性を使う．
      - 使用例： `Set-Cookie: x=123; Domain=example.jp`
      - `a.example.jp` が `Domain=example.jp` を指定して `b.example.jp` にもクッキー値が送られるようにすることはできるが，`Domain=foo.com` のように自身の接尾辞ではない “本当に関係ないドメイン” を指定することはできない．
        * そういった指定はブラウザ側が無視する．
        * 指定できてしまうとセッションIDの固定化攻撃の脆弱性となるため．
      - しかし `a.example.jp` と `b.example.jp` のようなドメインでも互いに運営者が違うことはあり，`Domain=example.jp` と設定すると前者のクッキーは後者に漏洩してしまうことになる．そのため，**基本的には `Domain` 属性は設定するものではない**．
        * 古いブラウザだと `Domain=co.jp` というドメインのクッキーが作れてしまう問題があり，例えば `yahoo.co.jp` から `amazon.co.jp` に簡単にセッションIDが漏れ得た．これは **クッキーモンスターバグ** (*Cookie Monster Bug*) と呼ばれる．
        * 地域型JPドメインと都道府県型JPドメインには案外最近のバージョンのブラウザまでクッキーモンスターバグがあった．これらのドメインを使う場合は固定化攻撃の対策に特に慎重を期する．
    * `Secure`
      - HTTPSの場合のみクッキーを送信するという指定．
      - →4.8.2項
    * `HttpOnly`
      - JavaScriptからこの属性にアクセスできるか否かの指定．
      - 固定化攻撃では，典型的には後述される **クロスサイトスクリプティング攻撃** によりJavaScriptを悪用してクッキーを盗み出すが，この属性をつけておくとその典型例に対して効果がある．
        * ただし全てのクロスサイトスクリプティング攻撃をこれで防げるわけではない．


## 3.2 受動的攻撃と同一オリジンポリシー

* 攻撃の種別
  - **能動的攻撃**： 攻撃者が直接攻撃対象のサーバに対してアクセスし改竄や漏洩などを試みること．
    * SQLインジェクションなど
  - **受動的攻撃**： Webサイト利用者に対して罠を仕掛けることにより，罠を閲覧したユーザを通してアプリケーションに攻撃を仕掛けようと試みること．
* 受動的攻撃の種別
  - 単純なもの
    * 罠サイトを開設し，ブラウザやプラグインなどの脆弱性を突くようなレスポンスを返すことで攻撃する．
  - 正規サイトの悪用
    * 正規サイトに何らかの不正操作を行ない（この段階だけ見ると能動的攻撃でもある），正規サイトにアクセスした閲覧者に攻撃の仕掛けられたレスポンスを返す．
    * 攻撃者から見れば，罠サイトに誘導する手間が要らない，利用者が多いと攻撃対象が拡大しやすい，などの利点がある．
    * よくある手法：
      - FTPのパスワードを不正入手しコンテンツを書き換える（→ 8.1節）
      - Webサーバの脆弱性を突いてコンテンツを書き換える（→ 8.1節）
      - SQLインジェクション（→ 4.4節）
      - SNSなどユーザが投稿できる機能のクロスサイトスクリプティング脆弱性につけこむ（→ 4.3節）
  - サイトをまたがるもの
    * 罠サイトを開設し，正規サイトへの攻撃となるリクエストを含むレスポンスを返すことで攻撃する．
    * 単に攻撃用のHTMLのURLが掲示板に貼られるなどの単純なものも多い．
    * よくある手法：
      - **クロスサイトリクエストフォージェリ** (CSRF)（→ 4.5節）
      - クロスサイトスクリプティング (XSS)（→ 4.3節，4.5節）
      - **HTTPヘッダインジェクション**（→ 4.7節）
* 受動的攻撃を防ぐ方法
  - ブラウザとWebサイトそれぞれが脆弱性を含まないようにする必要がある．
  - ブラウザによる対策： JavaScriptのサンドボクシング
    * ローカルファイルへのアクセスの禁止
    * **同一生成元ポリシー** (*same origin policy*)
      - 或るサイトが生成してクライアント側に送ったJavaScriptからは，別のサイトが生成してクライアント側に送ったDOMなどへの読み取りアクセスを禁止するセキュリティ上の制限．
      - これがないと，例えば悪意のあるサイトが `iframe` 要素で別サイトのページを読み込むことでそのページが取り扱うパスワードなどの内容をいくらでも取り出せてしまう．
      - 同一生成元であるとは以下の全てが一致している場合：
        * URLのホスト（つまりFQDN）
        * スキーム（プロトコル）
          - したがって同一のFQDNからでも例えばHTTPとHTTPSとでは異なる生成元とみなす．
        * ポート番号
      - Ajaxの `XMLHttpRequest` でアクセスできるURLにも同一生成元ポリシーが課されるが，意図的に同一生成元でないサイト間で跨ってやり取りしたい場合は相手側のサイトが許可すれば同一生成元でなくても通信できる **CORS** という規格がある（→ 3.3節）．
      - “`iframe` 要素の内側にJavaScriptを送って実行させる攻撃” （**クロスサイトスクリプティング**）ができるようになっているとこれは同一生成元ポリシーを以てしても防げない．
        * しかし実際にはアクセス解析用のソースやバナー広告，ブログパーツなど，第三者の提供するJavaScriptを許可せざるを得ない場合もある．これはサイト運営者または閲覧者がJavaScript提供元を信頼することで許可することになる．提供元が意図的に個人情報を収集していたり，提供元が意図しない動作が提供されたJavaScriptの脆弱性によって攻撃で差し替えられて発生したりするセキュリティ上の問題が頻繁に生じているので，慎重な判断を要する．このほか，ブラウザのアドオンにも同様の慎重さが必要（こちらはサイトが提供する通常のJavaScriptよりも強い権限で動作するのでさらに慎重を期する）．
      - `iframe` 以外でも `img`，`script`，`form` 要素の `action` 属性でクロスドメインが関わる．
        * `img` は特に制約なくクロスドメインでも指定可能．
        * `form` の送信もaction先がクロスドメインであっても操作可能．これを悪用するのがクロスサイトリクエストフォージェリ (CSRF)（→ 4.5節）．
        * `script` に関しては，（最近は全然名前を聞かないが）**JSONP** の取り扱いにリスクがある（→ 4.16.7項）．
        * CSSも特に制約なくクロスドメインでも指定可能．
          - ただし，かつてIEにはCSSでないデータがCSSとして読み出す際に部分的に読み出せてしまう脆弱性があり，**CSSXSS** と呼ばれていた．

## 3.3 CORS

* 同一生成元でないサイト間を跨ってデータをやり取りしたい場合はどうしてもあり，この要請に応える仕様として **CORS** (cross-origin resource sharing) が策定された．
* CORSに頼らなくとも，次を全て満たす **シンプルなリクエスト** の場合は提供側の許可なくできるようになっている：
  - メソッドはGET，HEAD，POSTのいずれか
  - `XMLHttpRequest` オブジェクトに対して `setRequestHeader` で設定されたHTMLヘッダが以下の範囲のみ：
    * `Accept`
    * `Accept-Language`
    * `Content-Language`
    * `Content-Type`
  - `Content-Type` ヘッダの値が以下のいずれか：
    * `text/plain`
    * `application/x-www-form-urlencoded`
    * `multipart/form-data`
* 以下でも述べるが，提供側が許可するドメインをレスポンスの `Access-Control-Allow-Origin` に与えることでブラウザに「このドメインに由来するJavaScriptコードからは私のレスポンスの内容を読み取っていいですよ」ということを伝えられるようになっている．
* シンプルなリクエストではないリクエストをクロスドメインで送信する場合，ブラウザはまず **プリフライトリクエスト** と呼ばれるHTTPリクエストを送信する．これには主に以下のようなヘッダを含める：
  - `Access-Control-Request-Method`
    * この後送る本番のリクエストメソッドが何であるかを伝え，メソッドに対する許可を得ようとする．
    * 例： `Access-Control-Request-Method: POST, GET, OPTIONS`
  - `Access-Control-Request-Headers`
    * 本番のリクエストメソッドに含めるヘッダを伝え，ヘッダに対する許可を得ようとする．
    * 例： `Access-Control-Request-Headers: content-type`
  - `Origin`
    * オリジンを伝え，許可を得ようとする．
    * 例： `Origin: http://example.jp`
* 提供側はプリフライトリクエストを受け取ったら403 Forbiddenを返して拒否するか，或いは以下のようなレスポンスヘッダを返して許可を出す：
  - `Access-Control-Allow-Origin`
  - `Access-Control-Allow-Methods`
  - `Access-Control-Allow-Headers`
* クッキーを受け取って使いたい場合は，`XMLHttpRequest` の `withCredentials` を `true` にしてリクエストを送る．
  - 提供側はそのリクエストに対して `Access-Control-Allow-Credentials: true` をヘッダにしてレスポンスを返す．するとクライアント側のブラウザは「提供元が許可した」と判断して `Set-Cookie` の内容を保持し，次回のリクエストにそのクッキーを含めるようになる．


# 4

## 4.1 Webアプリケーションの昨日と脆弱性の対応

## 4.2 入力処理とセキュリティ

* 入力を受けつける箇所で検証する項目：
  - エンコーディングの妥当性
  - エンコーディングの変換（必要であれば）
  - 入力値の文字列形式の妥当性
* 入力処理での検証の意義：
  - 内部エラーの防止
  - （内部エラーにはならないものの）データに不整合が生じる状況の防止
  - 入力値の誤りをクライアントやユーザに適切にフィードバックすることによるユーザビリティの向上
* **入力処理での検証の主目的はセキュリティのためではない**．
  - 入力値検証はアプリケーションの仕様に基づくものとし，脆弱性対策とは分離して定式化するのが良い．
  - “たまたま” 保険的に役立つことはある：
    * 例： SQLインジェクションの対策をしていなかったパラメータがあったが，英数字のみからなる文字列しか受けつけないバリデーションを入力処理に含めていたので実害に至らないようになっていた．
* **バイナリセーフ**： どんなバイト列が入力に来ても扱えること．特に `0x00`（ヌルバイト）が現れても処理できること．
  - ヌルバイトが現れるとそこを無条件に文字列終端と看なす仕様や実装の穴を突く攻撃手法が知られており，**ヌルバイト攻撃** と呼ばれる．
* 具体的な入力値の検証：
  - 制御文字のチェック
    * 注意： ここでは `0x20` は制御文字に含んでいない．
    * 例： 1行のテキストボックスなど改行を含んではいけない文字列なので，全ての制御文字を拒否する
  - 文字数のチェック
    * **全てのパラメータについて最大文字数を仕様として規定すべし**．
  - 数値の最大値と最小値のチェック
    * 数値の項目については取りうる値の最大値と最小値を仕様として規定すべし．

## 4.3 表示処理に伴う問題

### 4.3.1 XSS（基本編）

* XSSの被害例：
  - 攻撃者の用意したスクリプトの実行によりクッキー値を盗まれ，なりすましに使われる
  - 攻撃者の用意したスクリプトの実行により偽物の入力フォームが表示され，フィッシングにより個人情報を盗まれる
* クッキー値の盗み出し：
  - `"<p>「%s」の検索結果：</p>"` のような表示を行なう箇所で，ユーザの入力した検索文字列を表示する `%s` （これは `?search=…` というクエリパラメータ由来とする）に対してXSS対策が施されていない場合，`"<script>alert(document.cookie)</script>"` などと検索するとクッキーが表示できる．これは攻撃者本人のクッキーが表示されるだけだが，同様の方法論が罠サイトを用意することで別の利用者のクッキーの盗み出しに使える．罠サイトに `iframe` 要素を設けて，その `src` 属性にXSSを起こすクエリパラメータを追加した攻撃対象のURLを入れておく（特に上記のJavaScript断片を `alert` ではなくメールで送信するなどの函数に置換したものにしておく）と利用者のクッキーが盗める．
* ログイン機能がなく，かつJavaScriptを使っていない場合でも，formにXSSの脆弱性が潜むことがある．
  - formの文字列値に脆弱性対策が為されていない場合，`input` 要素の `value` 属性に `"\"></form>…"` という形の文字列値を与えて本来のフォームを終了させ，そこから `…` にCSSの絶対座標指定やz-indexを利用して罠のフォームを上書きする位置に置くなどの記述をして攻撃ができる．
  - コード例を見た方が早いので，126ページ参照．
  - したがって，利用者がJavaScriptを無効にしていてもXSSの被害にあう可能性は普通にある．
* 反射型XSSと持続型XSS
  - 攻撃用のスクリプトが攻撃対象とは別のサイトに置かれるXSSを **反射型XSS**，攻撃対象のDB等に保存されるようなXSSを **持続型XSS** と呼ぶ．
  - 持続型XSSの攻撃対象は，は典型的にはWebメールやSNS．利用者が罠サイトを避けるだけでは被害を防げない．
  - これらとは別に **DOM-based XSS** という概念もある（→ 4.17節）．
* 脆弱性の要因
  - 基本的には（`<` などの）“HTML上意味のある” 文字を（`&lt;` などへと）エスケープしていないことで生じる．
  - ただし，構文上の場所に応じてエスケープすべき方法は変わるので注意．
    * HTMLのタグに囲まれている部分のテキスト中と属性値の二重引用符で囲まれた文字列中とでは適切なエスケープ方法が違う．
    * 前者の場合は最低限 `<` と `&` とを文字参照へとエスケープしていればよい．
    * 後者の場合はそれに加えて `"` も最低限のエスケープ対象．
    * 属性値を二重引用符で囲んでいない場合は空白文字が値の終了と看なされるのでこれもXSSの抜け穴になる．恒に二重引用符で囲うべし．
* 保険的対策
  - ブラウザの中にはXSSの脆弱性と思しき入力を自前で検出して無害な出力に変換する機能（**XSSフィルタ** と呼ばれる）を持っているものもある．
  - XSSフィルタはデフォルトで有効だが，ユーザが無効に設定することもある．しかし `X-XSS-Protection: 1; mode=block` というヘッダをレスポンスに入れるとユーザの設定にかかわらずXSSフィルタを有効にできる（**恒にこれを追加することを推奨**）．
  - 4.2節で前述の通り，入力値検証が “たまたま” XSS対策になることがある．
  - クッキーの属性に `HttpOnly` をつけ，そもそもJavaScriptなどから読み取れないようにブラウザに指示する．
* 詳細は省かれているが，かつてはブラウザの脆弱性によりTRACEメソッドのJavaScriptによる送信がクッキーやBasic認証のIDとパスワードを盗み出せる **クロスサイトトレーシング**（**XST**）という攻撃手法があった．
  - 2006年頃には全主要ブラウザで対策が終わり，現在ではほぼリスクはないと言えるが，TRACEメソッドを許可していると脆弱性診断ツールが警告してくることはあるし，また例えばnginxのデフォルトの設定ではTRACEは許可されていない．

### 4.3.2 XSS（発展編）

* `href` 属性や `src` 属性では，URLとして `javascript:〈JavaScriptの式〉` という形式（**JavaScriptスキーム**）によってJavaScriptを起動できる．
  - これは二重引用符で囲われていても文字列がソースコードとして読み出されるので，`src="javascript:alert(document.cookie)"` などとなるように攻撃されたりしてXSSの要因となる（JavaScriptスキームとかいう厄介な仕様を用意してくれたもんだなあ）．
  - 対策：
    * 単に `http:` か `https:` か `/`（相対URL）で始まるもののみを許すようにチェックする．
    * さらに，1点目だけでは罠サイトを仕込まれるリスクがあるので，ドメイン名までチェックし，外部ドメインである場合はエラーにするか外部ドメインであることを注意喚起する（→ 詳細は4.7.1項）．
      - SNSなどで外部へのリンクを踏んだ際にクッションページが出るのはおそらくこれの対策．
* `body` の `onload` 属性．ここもJavaScriptコードを文字列で与えることができるので，XSSでコードが差し込まれる脆弱性となる．
  - そもそも挿入される値が “コードとして自由度が高い” 記述をしてはいけないが，`<body onload="init('%s')">` で `%s` をURLのクエリパラメータ `name` の値で埋めさせたい場合などがある．これは文字列リテラル中への埋め込みなので “自由度が低く” 比較的マシだが，これでも文字列リテラル宙の文字を適切にエスケープしないと `%s` の内容で文字列終端を勝手につくられてしまうXSSの脆弱性となる．例えば `');alert(document.cookie)//` を `name` に与えると `<body onload="init('');alert(document.cookie)//')">` という具合に攻撃できる．
  - 対策： JavaScriptの文字列リテラル中として，最低限 `\`，`"`，`'`，改行のエスケープが必要．
* `<script>…</script>` の中身にサーバサイドでユーザからの入力を含める場合
  - これも基本的には1つ前の項目と同じで，そもそも “自由度を高く” してはいけない．
  - ただし，こちらは文字列リテラル中のみであっても引用符や改行をエスケープするだけでは事足りない．`</script>` が挿入されるとJavaScriptコードとしての文脈に関わらずHTMLのパース上そこがコードの終端と扱われてしまうため．したがって `</script><script>alert(document.cookie)//` のような内容を挿入されるとXSSが起こされてしまったりする．
  - 対策：
    * `</script` という文字列が出現しないようにする．
    * そもそも漏れが発生しやすいのでJavaScriptコードに動的生成される部分を含めることを避ける．
    * **カスタムデータ属性** という，`script` 要素の外側でパラメータを定義してJavaScript側から参照する方法を用いる．
